> https://pan.baidu.com/s/1Kg7UUpO3wwALX6x28cWA7A
>
> 提取码：8op3
>
> 位置：全部文件/尚硅谷Java学科全套教程（总207.77GB）/1.尚硅谷全套JAVA教程--基础阶段（73.36GB）/MySQL核心技术

> 创建用户并收入全部权限
>
> grant all privileges on *.* to 'root'@'localhost' identified by '123456';

- MySql数据库的常见命令

  > 不区分大小写
  >
  > 每条命令最好用分号结尾
  >
  > 每条命令根据需要，可以进行缩进 或换行
  >
  > 注释
  >
  > ​		单行注释：#注释文字
  >
  > ​		单行注释：--  注释文字
  >
  > ​		多行注释： /* 注释文字 */

  - 数据库登录

    - mysql 【-h 主机名 -p 端口号】 -u 用户名  -p

    ```cmd
    C:\Users\Alex>mysql -u root -p
    Enter password: ******
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 14
    Server version: 5.5.53 MySQL Community Server (GPL)
    
    Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
    
    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.
    
    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
    
    mysql>
    ```

  - 显示已有数据库 show databases;

    > 记得加";"当然\g也可以

    ```mysql
    mysql> show databases;
    +--------------------+
    | Database           |
    +--------------------+
    | information_schema |
    | mysql              |
    | performance_schema |
    | test               |
    +--------------------+
    4 rows in set (0.00 sec)
    
    mysql> show databases\g
    +--------------------+
    | Database           |
    +--------------------+
    | information_schema |
    | mysql              |
    | performance_schema |
    | test               |
    +--------------------+
    4 rows in set (0.00 sec)
    ```

  - 打开指定数据库 use test ===> use 库名

    ```mysql
    mysql> use test
    Database changed
    ```

  - 显示数据库中的表（先选择数据库）show tables;

    ```mysql
    mysql> show tables;
    Empty set (0.00 sec)
    ```

  - 查看其他库的所有表 show tables from mysql;===>show tables from 库名;

    ```mysql
    mysql> show tables from mysql;
    +---------------------------+
    | Tables_in_mysql           |
    +---------------------------+
    | columns_priv              |
    | db                        |
    | event                     |
    | func                      |
    | general_log               |
    | help_category             |
    | help_keyword              |
    | help_relation             |
    | help_topic                |
    | host                      |
    | ndb_binlog_index          |
    | plugin                    |
    | proc                      |
    | procs_priv                |
    | proxies_priv              |
    | servers                   |
    | slow_log                  |
    | tables_priv               |
    | time_zone                 |
    | time_zone_leap_second     |
    | time_zone_name            |
    | time_zone_transition      |
    | time_zone_transition_type |
    | user                      |
    +---------------------------+
    24 rows in set (0.00 sec)
    ```

  - 查看数据库 select database();

    ```mysql
    mysql> select database();
    +------------+
    | database() |
    +------------+
    | test       |
    +------------+
    1 row in set (0.00 sec)
    ```

  - 创建数据表 create table stuinfo();

    > create table 表名(
    >
    > ​			列名  列类型,
    >
    > ​			列名  列类型,
    >
    > ​			……
    >
    > )

    ```mysql
    mysql> create table stuinfo(
        -> id int,
        -> name varchar(20));
    Query OK, 0 rows affected (0.31 sec)
    ```

  - 查看表结构 desc stuinfo;===> desc 表名;

    ```mysql
    mysql> show tables;
    +----------------+
    | Tables_in_test |
    +----------------+
    | stuinfo        |
    +----------------+
    1 row in set (0.00 sec)
    
    mysql> desc stuinfo;
    +-------+-------------+------+-----+---------+-------+
    | Field | Type        | Null | Key | Default | Extra |
    +-------+-------------+------+-----+---------+-------+
    | id    | int(11)     | YES  |     | NULL    |       |
    | name  | varchar(20) | YES  |     | NULL    |       |
    +-------+-------------+------+-----+---------+-------+
    2 rows in set (0.00 sec)
    ```

  - 查看表中的数据 select * from stuinfo;

    ```mysql
    mysql> select * from stuinfo;
    Empty set (0.00 sec)
    ```

  - 表中插入数据 insert into stuinfo (id,name) values(1,"john");

    ```mysql
    mysql> select * from stuinfo;
    Empty set (0.00 sec)
    
    mysql> insert into stuinfo (id,name) values(1,"john");
    Query OK, 1 row affected (0.00 sec)
    
    mysql> insert into stuinfo (id,name) values(2,"rose");
    Query OK, 1 row affected (0.00 sec)
    
    mysql> select * from stuinfo;
    +------+------+
    | id   | name |
    +------+------+
    |    1 | john |
    |    2 | rose |
    +------+------+
    2 rows in set (0.00 sec)
    ```

  - 删除表中数据 delete from stuinfo where id = 1;

    ```mysql
    mysql> delete from stuinfo where id = 1;
    Query OK, 1 row affected (0.00 sec)
    
    mysql> select * from stuinfo;
    +------+------+
    | id   | name |
    +------+------+
    |    2 | rose |
    +------+------+
    1 row in set (0.00 sec)
    ```

  - 查看服务器版本

    - 方法1： 登录到mysql服务端 select version();

    ```mysql
    mysql> select version();
    +-----------+
    | version() |
    +-----------+
    | 5.5.53    |
    +-----------+
    1 row in set (0.00 sec)
    ```

    - 方法2： 没有登录mysql服务端 mysql --version或者mysql --v

    ```cmd
    C:\Users\Alex>mysql --version
    mysql  Ver 14.14 Distrib 5.5.53, for Win32 (AMD64)
    ```

  - 数据库退出 exit

    ```mysql
    mysql> exit
    Bye
    ```

### 进阶1：基础查询✦

  ```mysql
# 进阶1：基础查询
/*
语法：
select 查询列表 from 表名;

类似于：System.out.println(打印东西);

特点:

1.查询列表可以是：表中的字段、常量值、表达式、函数
2.查询的结果是一个虚拟的表格
*/
USE myemployees ;

# 1.查询表中的单个字段
SELECT 
  last_name 
FROM
  employees ;

# 2.查询表中的多个字段
SELECT 
  last_name,
  salary,
  email 
FROM
  employees ;

# 3.查询表中的所有字段
SELECT 
  'employee_id',
  'first_name',
  'last_name',
  'phone_number',
  'job_id',
  'salary',
  'commission_pct',
  'manager_id',
  'department_id',
  'hiredate' 
FROM
  employees ;

SELECT 
  * 
FROM
  employees ;

# 4.查询常量值
SELECT 
  100 ;

SELECT 
  'john' ;

# 5.查询表达式
SELECT 
  100 % 98 ;

# 6.查询函数
SELECT 
  VERSION() ;

# 7.起别名
/*
①便于理解
②如果要查询的字段有重名的情况，使用别名可以区分开来

*/
# 方法1：
SELECT 
  100 % 98 AS 结果 ;

SELECT 
  last_name AS 姓,
  first_name AS 名 
FROM
  employees ;

# 方法2：
SELECT 
  last_name 姓,
  first_name 名 
FROM
  employees ;

# 案例：查询salary,显示结果为out put
SELECT 
  salary AS "out put" 
FROM
  employees ;

# 8.去重
DISTINCT # 案例：查询员工表中涉及到的所有的部门编号
SELECT DISTINCT 
  department_id 
FROM
  employees ;

# 9.+号的作用
/*
java中的+号：
①运算符：两个操作数都为数值形
②链接符：只要一个操作数为字符串

mysql中的+号：
仅仅一个功能：运算符

select 100+90; 两个操作数都为数值型，则做加法运算
select '123'+90; 其中一方为数值型，试图将字符型数值转换成数值型
                         如果转换成功，则继续做加分运算
select 'john'+90;        如果转换失败，则将字符型数值转换成0

select null+10;   只要其中一方为null，则结果肯定为null
                                             
*/
# 案例：查询员工名和姓连成一个字段，并显示为姓名
SELECT 
  CONCAT('a', 'b', 'c') AS 结果 ;

# select last_name+first_name as 姓名 from employees; # 错误示范
SELECT 
  CONCAT(last_name, first_name) AS 姓名 
FROM
  employees ;
  ```

  - 练习题

    - 下面的语句是否可以执行成功

    - 下面的语句是否可以执行成功

    - 找出下面的语句中的错误

    - 显示表departments的结构，并查询其中的全部数据

    - 显示出表employees的全部job_id（不能重复）

    - 显示出表employees的全部列，各个列之间用逗号连接，列头显示OUT_PUT

    ```mysql
    # 1. 下面的语句是否可以执行成功
    select last_name,job_id,salary as sal
    from employees;
    
    # 2.下面的语句是否可以执行成功
    select * from employees;
    
    # 3. 找出下面的语句中的错误
    select employee_id,last_name,
    salary * 12 as "ANNUAL SALARY"
    from employees;
    
    # 4. 显示表departments的结构，并查询其中的全部数据
    desc departments;
    select * from departments;
    
    # 5. 显示出表employees的全部job_id（不能重复）
    select distinct job_id from employees;
    
    # 6. 显示出表employees的全部列，各个列之间用逗号连接，列头显示OUT_PUT
    select 
           ifnull(commission_pct,0) as 奖金率,
           commission_pct
    from
           employees;
    
    # 意思一下就可以了，employees中太多列了
    select
          concat(first_name,',',last_name,',',ifnull(commission_pct,0)) as out_put
    from
          employees;
    ```

### 进阶2：条件查询✦

  ```mysql
# 进阶2：条件查询
/*
语法：
     select
           查询列表
     from
           表名
     where
           筛选条件;
           

分类：
     一、按条件表达式筛选
     条件运算符：> < = != <> >= <=
     二、按逻辑表达式筛选
     作用：连接条件表达式
     逻辑运算符：
              && || !
              and or not  ==> 与、或、非
     三、模糊查询
              like
              between and
              in
              is null
*/
# 1. 按条件表达式筛选
# 案例1：查询工资>12000的员工信息
SELECT 
  * 
FROM
  employees 
WHERE salary > 12000 ;

# 案例2：查询部门编号不等于90号的员工名和部门编号
SELECT 
  last_name,
  department_id 
FROM
  employees 
WHERE department_id != 90 ;

# 2. 按逻辑表达式筛选
# 案例1，查询工资在10000到20000之间的员工名、工资以及奖金
SELECT 
  last_name,
  salary,
  commission_pct 
FROM
  employees 
WHERE salary >= 10000 
  AND salary <= 20000 ;

# 案例2：查询部门编号不在90到100之间，或者工资高于15000的员工信息
SELECT 
  * 
FROM
  employees 
WHERE department_id < 90 
  OR department_id > 90 
  OR salary > 15000 ;

# 3. 模糊查询
/*
like
特点：
①一般和通配符搭配使用
           通配符:
           % 任意多个字符 ===>'%a%' 代表任何位置包含字母 a 的所有字符串
           _ 任意单个字符

between and
in
is null | is not null
*/
# 1.like
# 案例1：查询员工名中包含字符a的员工信息
SELECT 
  * 
FROM
  employees 
WHERE last_name LIKE '%a%' ;

# 案例2：查询员工名中第三个字符为n，第五个字符为l的员工名和工资
SELECT 
  last_name,
  salary 
FROM
  employees 
WHERE last_name LIKE '__n_l%' ;

# 案例3：查询员工名中第二个字符为_的员工名
SELECT 
  last_name 
FROM
  employees 
WHERE last_name LIKE '_\_%' ;

# last_name like '_$_%' escape '$';
# 使用 ESCAPE 关键字定义转义符
# 2.between and
/*
①使用between and 可以提高语句的简洁度
②包含临界值
③两个临界值不要调换顺序
*/
# 案例1：查询员工编号在100到120之间的员工信息
SELECT 
  * 
FROM
  employees 
WHERE # employee_id >= 100 and employee_id <= 120; # 原先
  employee_id BETWEEN 100 
  AND 120 ;

# 3.in
/*
含义：判断某字段的值是否属于in列表中的某一项
特点：
      ①使用in提高语句简洁度
      ②in列表的值类型必须一致或者兼容
*/
# 案例1：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号
SELECT 
  last_name,
  job_id 
FROM
  employees 
WHERE # job_id = 'IT_PROG' or job_id = 'AD_VP' or job_id = 'AD_PRES'; # 原先
  job_id IN ('IT_PROG', 'AD_VP', 'AD_PRES') ;

# 4.is null
/*
=或<>不能用于判断null值
is null 或者 is not null 可以判断null值


*/
# 案例1：查询没有奖金的员工名和奖金率
SELECT 
  last_name,
  commission_pct 
FROM
  employees 
WHERE commission_pct IS NULL ;

# 案例2：查询有奖金的员工名和奖金率
SELECT 
  last_name,
  commission_pct 
FROM
  employees 
WHERE commission_pct IS NOT NULL ;

# 安全等于 <=>
# 案例1：查询没有奖金的员工名和奖金率
SELECT 
  last_name,
  commission_pct 
FROM
  employees 
WHERE commission_pct <=> NULL ;

# 案例2：查询工资为12000的员工信息
SELECT 
  * 
FROM
  employees 
WHERE salary <=> 12000 ;

# is null pk <=>
# is null: 仅判断NULL值,可读性较大
# <=>    : 既可以判断NULL值，又可以判断普通的数值
  ```

  - 练习题
  
    ```mysql
    # 1. 查询工资大于12000的员工信息
    select
          *
    from
          employees
    where
          salary > 12000;
    
    
    # 2. 查询员工号为176的员工的姓名和部门号和年薪
    
    select
          last_name,
          department_id,
          salary*12*(1+ifnull(commission_pct,0)) as 年薪
    from
          employees
    where
          employee_id <=> 176;
    
    # 3. 选择工资不在5000到12000的员工的姓名和工资
    
    select
          last_name,
          salary
    from
          employees
    where
          salary < 5000 or salary > 12000
    
    # 4. 选择在20或50号部门工作的员工名和部门号
    
    select
          last_name,
          department_id
    from
          employees
    where
          department_id = 20 or department_id = 50
    
    # 5. 选择公司中没有管理者的员工名以及Job_id
    
    select
          last_name,
          job_id
    from
          employees
    where
          manager_id is null
    
    # 6. 选择公司中有奖金的员工名、工资和奖金级别
    
    select
          last_name,
          salary,
          commission_pct
    from
          employees
    where
          commission_pct is not null
    
    # 7. 选择员工姓名的第三个字母是a的员工名
    
    select
          last_name
    from
          employees
    where
          last_name like '__a%'
    
    ```
  
- 测试题

  ```mysql
  # 测试题
  # 1. 查询没有奖金，且工资小于18000的salary,last_name
  select
        salary,
        last_name
  from
        employees
  where
        commission_pct is null and salary < 18000;
  
  # 2. 查询employees表中，job_id不为'IT'或者 工资为12000的员工信息
  select
        *
  from
        employees
  where
        job_id != 'IT' or salary = 12000;
  
  # 3. 查看部门departments表的结构，查询效果如下：
  ……
  
  use myemployees;
  desc departments;
  
  # 4. 查询部门departments表中涉及到那些位置编号
  
  select distinct
        location_id
  from
        departments;
  
  # 5. 试问：select * from employees; 
  # 和 select * from employees where commission_pct like '%%' and last_name like '%%';
  # 结果是否一样？并说明原因
  
  select * from employees; 
  select * from employees where commission_pct like '%%' and last_name like '%%';
  
  # 不一样
  # 如果判断的字段有null值的话
  ```

### 复习：数据库的相关概念

- 复习：数据库的相关概念

  - 数据库的好处

    - 可以持久数据到本地
    - 结构化查询

  - 数据的常见概念✦

    - DB：数据库，存储数据的容器
    - DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB
    - SQL：结构化查询语言，用于和数据库的通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言

  - 数据库储存数据的特点

    - 数据存放到表中，然后再放到库中
    - 一个库可以有多张表，每张表具有唯一的表名用来标识自己
    - 表中有一个或多个列，列又称为“字段”，相当于java中的“属性”
    - 表中的每一行数据，相当于java中“对象”

  - 常见的数据库管理系统

    mysql、oracle、db2、sqlserver


### 复习：MySQL的介绍

- 复习：MySQL的介绍

  - MySQL的背景

    - 前身属于瑞典的一家公司，MySQL AB
    
    - 08年被sun公司收购
    - 09年sun被oracle收购
    
  - MySQL的优点
  
    - 开源、免费、成本低
  - 性能高、移植性也好
  
  - 体积小、便于安装
  
- MySQL的安装★
  
    - 属于C/S架构(服务端和客户端都有)的软件，一般来讲安装服务端
  - 企业版、社区版
  
- MySQL服务的启动和停止★
  
  - 方法一：通过命令行
  
      ```cmd
    net start 服务名
    net stop 服务名
    ```
  
  - 方法二：计算机--右键--管理--服务
  
- MySQL服务的登录和登出★
  
  - 登录
  
      ```cmd
    mysql 【-h 主机名 -p 端口号】 -u 用户名 -p密码
      # -h、-p、-u后面可以加空格，但是-p后面不能加空格
      # 输完-p就回车，可以隐藏密码
    ```
  
  - 退出
  
    exit或者Ctrl+C
  

### 复习：DQL语言-基础查询★

- 复习：DQL语言-基础查询

  - 语法

    ```mysql
    select 查询列表
    from 表名;
    ```
  - 特点
    
      - 查询列表可以是字段、常量、表达式、函数，也可以是多个
    - 查询结果是一个虚拟表
  - 示例

    - 查询单个字段

      ```mysql
      select 字段名 from 表名;
      ```

      

    - 查询多个字段

      ```mysql
      select 字段名1,字段名2 from 表名;
      ```

      

    - 查询所有字段

      ```mysql
      select * from 表名;
      ```

      

    - 查询常量

      ```mysql
      select 常量值;
      select 常量值 from 表名;
          
      # 注意：字符型和日期型的常量值必须单引号引起来，数值型不需要
      select 函数名(实参列表);
      # 函数必须有返回值
      ```

      

    - 查询表达式

      ```mysql
      select 表达式;
      # 仅支持加、减、乘、除、取幂
      ```

    - 起别名

      - as
      - 空格

    - 去重

      ```mysql
      select distinct 字段名 from 表名;
      ```

    - 加号

      作用：仅做加法运算

      ```mysql
      select 数值+数值;
      # 直接运算
      select 字符+数值;
      # 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算
      select null+值;
      # 结果都为null
      ```

    - concat函数

      功能：拼接字符

      ```mysql
      select concat(字符1,字符2……);
      ```

    - ifnull函数

      功能：判断某字段或表达式是否为null，如果为null，返回指定值，否则返回原本值

      ```mysql
      select ifnull(conmission_pact,0) from employees;
      ```

    - isnull函数

      功能：判断某字段或表达式是否为null，如果是，则返回1；否则返回0；

      ```mysql
      select isnull(conmission_pact) from employees;
      ```

### 复习：DQL语言-条件查询★

- 复习：DQL语言-条件查询

  - 语法

    ```mysql
    select 查询列表
    from 表名
    where 筛选条件;
    ```

  - 筛选条件的分类

    - 简单条件运算符

      ```mysql
      >
      # 大于
      <
      # 小于
      =
      # 等于
      <> !=
      # 不等于
      >=
      # 大于等于
      <=
      # 小于等于
      <=>
      # 安全等于
      ```

    - 逻辑运算符

      ```mysql
      && and
      # 与
      || or
      # 或
      ! not
      # 非
      ```

    - 模糊查询

      ```mysql
      like
      # 一般搭配通配符使用，可以判断字符型或数值型
      # select * from employees where department_id like '1__';
      # 通配符：%任意多个字符，_任意单个字符
      beteen a and b
      in
      is null / is not null
      # 用于判断null
      ```

      - is null PK <=>

      |         | 普通类型的数值 | null值 | 可读性 |
      | ------- | -------------- | ------ | ------ |
      | is null | ✗              | ✓      | ✓      |
      | <=>     | ✓              | ✓      | ✓      |

### 进阶3：排序查询✦

  ```mysql
# 进阶3：排序查询
/*
引入：
   select * from employees;
   
语法：
   select 查询列表
   from 表
   【where 筛选条件】
   order by 排序列表 【asc|desc】

特点：
   1.asc 代表升序，desc 代表降序
   如果都不写，默认升序
   2.order by 子句中可支持单个字段，多个字段，表达式，函数，别名
   3.order by 子句一般放在查询语句的最后面，但是limit子句除外
*/
# 案例1：查询员工信息：要求工资从高到低排序
# 从低到高
SELECT 
  * 
FROM
  employees 
ORDER BY salary ASC ;

SELECT 
  * 
FROM
  employees 
ORDER BY salary ;

# 从高到低
SELECT 
  * 
FROM
  employees 
ORDER BY DESC ;

# 案例2：查询部门编号>=90的员工信息，按照入职时间的先后进行排序【添加筛选条件】
SELECT 
  * 
FROM
  employees 
WHERE department_id >= 90 
ORDER BY hiredate ;

# 案例3：按年薪的高低显示员工的信息和年薪【按表达式排序】
SELECT 
  *,
  salary * 12 * (1+ IFNULL(commission_pct, 0)) AS 年薪 
FROM
  employees 
ORDER BY salary * 12 * (1+ IFNULL(commission_pct, 0)) DESC ;

# 案例4：按年薪的高低显示员工的信息和年薪【按别名排序】
SELECT 
  *,
  salary * 12 * (1+ IFNULL(commission_pct, 0)) AS 年薪 
FROM
  employees 
ORDER BY 年薪 DESC ;

# 案例5：查询姓名的长度显示员工的姓名和工资【按函数排序】
SELECT 
  LENGTH(last_name) AS 字节长度,
  last_name,
  salary 
FROM
  employees 
ORDER BY LENGTH(last_name) DESC ;

SELECT 
  LENGTH(last_name) AS 字节长度,
  last_name,
  salary 
FROM
  employees 
ORDER BY 字节长度 DESC ;

# 案例6：查询员工信息，要求先按工资排序，再按员工编号排序【按多个字符排序】
SELECT 
  * 
FROM
  employees 
ORDER BY salary ASC,
  employee_id ASC ;
  ```

  - 练习题

    ```mysql
    # 测试题
    # 1. 查询员工的姓名和部门号和年薪，按年薪降序，按姓名升序
    select last_name,department_id,salary*12*(1+ifnull(commission_pct,0)) as 年薪
    from employees
    order by 年薪 desc,last_name asc;
    
    # 2. 选择工资不在8000到17000的员工的姓名和工资，按工资降序
    select last_name,salary
    from employees
    where salary not between 8000 and 17000
    order by salary desc;
    
    # 3. 查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序
    select *
    from employees
    where email like '%e%'
    order by length(email) desc,department_id asc;
    ```

### 进阶4：常见函数✦

  ```mysql
# 进阶4：常见函数
/*
功能：
   类似于java的方法，将一组逻辑语句封装在方法中，对外暴露方法名
好处：
   1. 隐藏了实现细节 2. 提交代码重用性
调用：
   select 函数名(实参列表) from 表;
特点：
   1. 该方法叫什么(函数名)
   2. 该函数是干什么的(函数功能)
分类：
   1.单行函数
   concat length ifnull等
   2.分组函数
   功能：做统计使用，又称为统计函数、聚合函数、组函数
常见函数：
	字符函数：
		length
		concat
		substr
		instr
		trim
		upper
		lower
		ipad
		rpad
		replace
	数学函数：
		round
		ceil
		floor
		truncate
		mod
	日期函数：
		now
		curtime
		curdate
		year
		month
		monthnane
		day
		hour
		minute
		second
		str_to_date
		date_format
	其他函数：
		version
		database
		user
	控制函数：
		if
		case
		
*/
  ```

  - 单行函数

      - 字符函数

        ```mysql
        # 一.字符函数
        # 1.length 获取参数数值的字节个数
        SELECT 
          LENGTH('john') ;

        SELECT 
          LENGTH('张三丰hahaha') ;

        # 一个汉字占3个字节，一个英文字母占1个字节
        # 2.concat 拼接字符串
        SELECT 
          CONCAT(last_name, '_', first_name) 
        FROM
          employees ;

        # 3.upper、lower 大小写
        SELECT 
          UPPER('john') ;

        SELECT 
          LOWER('JOHN') ;

        # 示例：将姓大写，名小写，然后拼接
        SELECT 
          CONCAT(UPPER(last_name), LOWER(first_name)) AS 姓名 
        FROM
          employees ;

        # 4.substr,substring 索引从1开始
        # 截取从指定索引处后面的所有字符
        SELECT 
          SUBSTRING(
            '李莫愁爱上了陆展元',
            7
          ) ;

        # 截取从指定索引处指定长度的字符
        SELECT 
          SUBSTRING(
            '李莫愁爱上了陆展元',
            1,
            3
          ) ;

        # 案例：姓名中首字符大写，其他字符小写，然后用_拼接，显示出来
        SELECT 
          CONCAT(
            UPPER(SUBSTRING(last_name, 1, 1)),
            '_',
            LOWER(SUBSTRING(last_name, 2))
          ) 
        FROM
          employees ;

        # 5.instr 返回子串第一次出现的索引，如果找不到返回0
        SELECT 
          INSTR(
            '杨不悔爱上了殷六侠',
            '殷六侠'
          ) ;

        # 6.trim 去前后
        SELECT 
          LENGTH(TRIM('  张翠山  ')) ;

        SELECT 
          TRIM('a' FROM 'aaa张翠aaa三aaaa') ;

        # 7.lpad 用指定的字符实现左填充指定长度
        SELECT 
          LPAD('殷素素', 10, '*') ;

        SELECT 
          LPAD('殷素素', 2, '*') ;

        # 殷素
        # 8.rpad 用指定的字符实现右填充指定长度
        SELECT 
          RPAD('殷素素', 12, 'ab') ;

        # 9.replace 替换
        SELECT 
          REPLACE(
            '周芷若周芷若周芷若周芷若张无忌爱上了周芷若',
            '周芷若',
            '赵敏'
          ) ;
        ```

      - 数学函数

        ```mysql
        # 二、数学函数
        # 1.round 四舍五入
        SELECT 
          ROUND(1.65) ;

        # 2.ceil 向上取整
        SELECT 
          CEIL(1.4) ;

        # 3.floor 向下取整
        SELECT 
          FLOOR(1.9) ;

        # 4.truncate 截断 小数点后去几位
        SELECT 
          TRUNCATE(1.1699, 1) ;

        # 5.mod 取余
        # MOD(a,b) ==> a-a/b*b
        SELECT 
          MOD(10, 3) ;

        SELECT 
          10 % 3 ;

        ```

      - 日期函数

        ```mysql
        # 三、日期函数
        # 1.now 返回当前系统日期+时间
        SELECT 
          NOW() ;

        # 2.curdate 返回当期系统日期
        SELECT 
          CURDATE() ;

        # 3.curtime 返回当前系统时间
        SELECT 
          CURTIME() ;

        # 可以获取指定的部分，年、月、日、小时、分钟、秒
        SELECT 
          YEAR(NOW()) AS 年 ;

        SELECT 
          YEAR('1999-6-7') AS 年 ;

        SELECT 
          YEAR(hiredate) AS 年 
        FROM
          employees ;

        SELECT 
          MONTH(NOW()) AS 月 ;

        # 4.str_to_date：将日期格式的字符转换成指定格式的日期
        SELECT 
          STR_TO_DATE('1-9-2019', '%c-%d-%Y') ;

        # 查询入职日期为1992-4-3的员工信息
        SELECT 
          * 
        FROM
          employees 
        WHERE hiredate = '1992-4-3' ;

        SELECT 
          * 
        FROM
          employees 
        WHERE hiredate = STR_TO_DATE('4-3 1992', '%c-%d %Y') ;

        # 5.date_format：将日期转换成字符
        SELECT 
          DATE_FORMAT('1992/4/3', '%Y年%c月%d日') ;

        # 查询有奖金的员工名和入职日期(xx月/xx日 xx年)
        SELECT 
          last_name,
          DATE_FORMAT(hiredate, '%m月/%d日 %y年') 
        FROM
          employees 
        WHERE commission_pct IS NOT NULL ;
        ```
        ![image-20201009132356623](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201009132356623.png)
        
    - 其他函数
      
      ```mysql
      # 四、其他函数 
      # 查看数据库版本
        SELECT 
          VERSION() ;
        
      # 查看数据库
        SELECT 
          DATABASE() ;
        
      # 查看当前登陆的用户
        SELECT 
          USER() ;
      ```
      
    - 流程控制函数
      
      ```mysql
      # 五、流程控制函数
      # 1.if函数 if else的效果
      SELECT 
        IF(10 > 5, '大', '小') ;
      
      SELECT 
        last_name,
        IF(
          commission_pct IS NULL,
          '没奖金',
          '有奖金'
        ) 
      FROM
        employees ;
      
      # 2.case函数的使用一：switch case的效果
      /*
      switch(变量或表达式){
      	case 常量:语句;break;
      	……
      	default:语句;break;
      }
      
      case 要判断的字段或表达式
      when 常量1 then 要显示的值1或语句1;
      when 常量2 then 要显示的值2或语句2;
      ……
      else 要显示的值n或语句n;
      end
      */
      /*案例：查询员工的工资，要求
      
      部门 = 30，显示工资为1.1倍
      部门 = 40，显示工资为1.2倍
      部门 = 50，显示工资为1.3倍
      其他的部门，显示工资为原工资
      
      */
      SELECT 
        salary,
        department_id,
        CASE
          department_id 
          WHEN 30 
          THEN salary * 1.1 
          WHEN 40 
          THEN salary * 1.2 
          WHEN 50 
          THEN salary * 1.3 
          ELSE salary 
        END AS 新工资 
      FROM
        employees ;
      
      # 3.case函数的使用二：类似于 多重if
      /*
      java中：
      if(条件1){语句1}
      else if(条件2){语句2}
      ……
      else{语句n}
      
      在mysql中：
      case
      when 条件1 then 要显示的值1或语句1;
      when 条件2 then 要显示的值2或语句2;
      ……
      else 要显示的值n或语句n;
      end
      */
      # 案例：查询出员工的工资情况
      /*
      如果工资>20000,显示A级别
      如果工资>15000,显示B级别
      如果工资>10000,显示C级别
      否则,显示D级别
      */
      SELECT 
        salary,
        CASE
          WHEN salary > 20000 
          THEN 'A' 
          WHEN salary > 15000 
          THEN 'B' 
          WHEN salary > 10000 
          THEN 'C' 
          ELSE 'D' 
        END AS 工资情况 
      FROM
        employees ;
      ```
      
    - 练习题
      
      ```mysql
      # 测试题
      # 1. 显示系统时间(注：日期+时间)
      SELECT 
        NOW() ;
      
      # 2. 查询员工号，姓名，工资，以及工资提高百分之20之后的结果(newsalary)
      SELECT 
        employee_id,
        last_name,
        salary,
        salary * 1.2 AS "new salary" 
      FROM
        employees ;
      
      # 3. 将员工的姓名按首字母排序，并写出姓名的长度(length)
      SELECT 
        *,
        LENGTH(last_name) AS 长度 
      FROM
        employees 
      ORDER BY SUBSTR(last_name, 1, 1) ;
      
      # 4. 做一个查询，产生下面的结果
      # <last name>earns<salary>monthly but wants<salary*3>
      # Dream Salary
      # King earns 24000 mothly but wants 72000
      SELECT 
        CONCAT(
          last_name,
          'earns',
          salary,
          'monthly but wants',
          salary * 3
        ) AS Dream Salary 
      FROM
        employees 
      WHERE salary = '24000' ;
      
      # 5. 使用case-when，按照下面的条件
      # job     grade
      # AD_PRES A
      # ST_MAN  B
      # IT_PROG C
      SELECT 
        job_id AS job,
        CASE
          job_id 
          WHEN 'AD_PRES' 
          THEN 'A' 
          WHEN 'ST_MAN' 
          THEN 'B' 
          WHEN 'IT_PROG' 
          THEN 'C' 
        END AS grade 
      FROM
        employees ;
      ```
      
    
  - 分组函数

      ```mysql
      # 分组函数
      /*
      功能：用作统计使用，又称为聚合函数或统计函数或组函数
      
      分类：
      sum求和、avg平均值、max最大值、min最小值、count计算个数
      
      特点：
      1. sum、avg一般用于处理数值型
         max、min、count可以处理任何类型
      2. 是否忽略null值
         以上分组函数都忽略null值
      3. 可以和distinct搭配实现去重的运算
      
      4. count函数的单独介绍
         一般使用count(*)用作统计行数
      5. 和分组函数一同查询的字段要求group by之后的字段
         
      */
      # 1. 简单的使用
      SELECT 
        SUM(salary) 
      FROM
        employees ;
      
      SELECT 
        AVG(salary) 
      FROM
        employees ;
      
      SELECT 
        MAX(salary) 
      FROM
        employees ;
      
      SELECT 
        MIN(salary) 
      FROM
        employees ;
      
      SELECT 
        COUNT(salary) 
      FROM
        employees ;
      
      SELECT 
        SUM(salary),
        AVG(salary),
        MAX(salary),
        MIN(salary),
        COUNT(salary) 
      FROM
        employees ;
      
      SELECT 
        SUM(salary),
        ROUND(AVG(salary), 2),
        MAX(salary),
        MIN(salary),
        COUNT(salary) 
      FROM
        employees ;
      
      # 2. 参数支持哪些类型
      SELECT 
        SUM(last_name),
        AVG(last_name) 
      FROM
        employees ;
      
      SELECT 
        SUM(hiredate),
        AVG(hiredate) 
      FROM
        employees ;
      
      SELECT 
        MAX(last_name),
        MIN(last_name) 
      FROM
        employees ;
      
      SELECT 
        MAX(hiredate),
        MIN(hiredate) 
      FROM
        employees ;
      
      SELECT 
        COUNT(commission_pct) 
      FROM
        employees ;
      
      # 3. 忽略null
      SELECT 
        SUM(commission_pct),
        AVG(commission_pct),
        SUM(commission_pct) / 35,
        SUM(commission_pct) / 107 
      FROM
        employees ;
      
      # 4. 和distinct搭配
      SELECT 
        SUM(DISTINCT salary),
        SUM(salary) 
      FROM
        employees ;
      
      SELECT 
        COUNT(DISTINCT salary),
        COUNT(salary) 
      FROM
        employees ;
      
      # 5. count函数的详细介绍
      SELECT 
        COUNT(salary) 
      FROM
        employees ;
      
      SELECT 
        COUNT(*) 
      FROM
        employees ;
      
      SELECT 
        COUNT(1) 
      FROM
        employees ;
      
      # 效率：
      # MYISAM 存储引擎下,COUNT(*)的效率高
      # INNODB 存储引擎下,COUNT(*)和 COUNT(1)的效率差不多，比 COUNT('字段')要高一些
      # 6. 和分组函数一同查询的字段有限制
      SELECT 
        AVG(salary),
        employee_id 
      FROM
        employees ;
      ```

      - 练习题

          ```mysql
          # 练习题
          # 1. 查询公司员工工资的最大值，最小值，平均值，总和
          SELECT 
            MAX(salary),
            MIN(salary),
            AVG(salary),
            SUM(salary) 
          FROM
            employees ;
          
          # 2. 查询公司员工表中最大入职时间和最小入职时间的相差天数(DIFFRENCE)
          # select max(hiredate)-min(hiredate) as DIFFRENCE
          SELECT 
            DATEDIFF(MAX(hiredate), MIN(hiredate)) AS DIFFRENCE 
          FROM
            employees ;
          
          # 3. 查询部门编号为90的员工个数
          SELECT 
            COUNT(*) 
          FROM
            employees 
          WHERE department_id = 90 ;
          ```

### 进阶5：分组查询✦

```mysql
# 进阶5：分组查询
/*
语法：
	select 分组函数，列(要求出现在group by的后面)
	from 表
	【where 筛选条件】
	group by 分组的列表
	【order by 子句】
	
注意：
	查询列表必须特殊，要求是分组函数和group by后面出现的字段
特点：
	1.分组查询中的筛选条件分为两类
			   数据源		位置
	分组前筛选where	   原始表		group by 子句的前面
	分组后筛选having   分组后的结果集	group by 子句的后面
	
	①分组函数做条件肯定是放在having子句中
	②能用分组前筛选的，就优先考虑使用分组前筛选
	2.group by 子句支持单个字段分组，多个字段分组(多个字段之间用逗号隔开没有顺序要求)，也可以支持表达式或函数(用的较少)
	3.也可以添加排序(排序放在分组查询的最后)
	
*/
# 引入：查询每个部门的平均工资
SELECT 
  AVG(salary) 
FROM
  employees ;

SELECT 
  department_id,
  AVG(salary) 
FROM
  employees 
GROUP BY `department_id` ;

# 简单的分组查询
# 案例1：查询每个工种的最高工资
SELECT 
  MAX(salary),
  job_id 
FROM
  employees 
GROUP BY job_id ;

# 案例2：查询每个位置上的部门个数
SELECT 
  COUNT(*),
  location_id 
FROM
  departments 
GROUP BY location_id ;

# 添加筛选条件
# 案例1：查询邮箱中包含a字符的，每个部门的平均工资
SELECT 
  AVG(salary),
  email,
  department_id 
FROM
  employees 
WHERE email LIKE '%a%' 
GROUP BY department_id ;

# 案例2：查询有奖金的每个领导手下员工的最高工资
SELECT 
  MAX(salary),
  manager_id 
FROM
  employees 
WHERE commission_pct IS NOT NULL 
GROUP BY manager_id ;

# 添加复杂的筛选条件
# 案例1：查询哪个部门的员工个数>2
# ①查询每个部门的员工个数
SELECT 
  COUNT(*),
  department_id 
FROM
  employees 
GROUP BY department_id ;

# ②根据①的结果进行筛选，查询哪个部门员工个数>2
SELECT 
  COUNT(*),
  department_id 
FROM
  employees 
GROUP BY department_id 
HAVING COUNT(*) > 2 ;

# 案例2：查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资
# ①查询每个工种有奖金的员工的最高工资
SELECT 
  MAX(salary),
  job_id 
FROM
  employees 
WHERE commission_pct IS NOT NULL 
GROUP BY job_id ;

# ②根据①结果继续筛选，最高工资>12000
SELECT 
  MAX(salary),
  job_id 
FROM
  employees 
WHERE commission_pct IS NOT NULL 
GROUP BY job_id 
HAVING MAX(salary) > 12000 ;

# 案例3：查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个，以及其最低工资
SELECT 
  MAX(salary),
  MIN(salary),
  manager_id 
FROM
  employees 
WHERE manager_id > 102 
GROUP BY manager_id 
HAVING MIN(salary) > 5000 ;

# 按表达式或函数分组
# 案例：按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些
SELECT 
  COUNT(*),
  LENGTH(last_name) 
FROM
  employees 
GROUP BY LENGTH(last_name) 
HAVING COUNT(*) > 5 ;

# 按多个字段分组
# 案例：查询每个部门每个工种的员工的平均工资
SELECT 
  AVG(salary),
  department_id,
  job_id 
FROM
  employees 
GROUP BY department_id,
  job_id ;

# 添加排序
# 案例：查询每个部门每个工种的员工的平均工资，并按平均工资的高低排序
SELECT 
  AVG(salary),
  department_id,
  job_id 
FROM
  employees 
GROUP BY department_id,
  job_id 
ORDER BY AVG(salary) DESC ;

# 部门不可为null
SELECT 
  AVG(salary),
  department_id,
  job_id 
FROM
  employees 
WHERE department_id IS NOT NULL 
GROUP BY department_id,
  job_id 
ORDER BY AVG(salary) DESC ;

# 平均工资> 10000
SELECT 
  AVG(salary),
  department_id,
  job_id 
FROM
  employees 
WHERE department_id IS NOT NULL 
GROUP BY department_id,
  job_id 
HAVING AVG(salary) > 10000 
ORDER BY AVG(salary) DESC ;
```

- 测试题

  ```mysql
  # 测试题
  # 1. 查询各job_id的员工工资的最大值、最小值、平均值、总和，并按job_id升序
  SELECT 
    job_id,
    MAX(salary),
    MIN(salary),
    AVG(salary),
    SUM(salary) 
  FROM
    employees 
  GROUP BY job_id 
  ORDER BY job_id ;
  
  # 2. 查询员工最高工资和最低工资的差距(DIFFERENCE)
  SELECT 
    MAX(salary),
    MIN(salary),
    MAX(salary) - MIN(salary) AS DIFFERENCE 
  FROM
    employees ;
  
  # 3. 查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内
  SELECT 
    manager_id,
    MIN(salary) 
  FROM
    employees 
  WHERE manager_id IS NOT NULL 
  GROUP BY manager_id 
  HAVING MIN(salary) >= 6000 ;
  
  # 4. 查询所有部门编号，员工数量和工资平均值，并按平均工资降序
  SELECT 
    department_id,
    COUNT(*),
    AVG(salary) 
  FROM
    employees 
  GROUP BY department_id 
  ORDER BY AVG(salary) DESC ;
  
  # 5. 查询具有各个job_id的员工人数
  SELECT 
    job_id,
    COUNT(*) 
  FROM
    employees 
  GROUP BY job_id ;
  ```

  

### 进阶6：连接查询✦

   ```mysql
# 进阶6：连接查询
/*
含义：又称为多表查询，当查询的字段来自多个表的时，就需要要多表查询

笛卡尔乘积现象：表1 有m行，表2 有n行，结果m*n行

发生原因：没有有效的连接条件
如何避免：添加有效的连接条件

分类：
	按年代分类：
	sql92标准：仅支持内连接
	sql99标准【推荐】：支持所有内连接+外连接(左外+右外)+交叉连接
	
	按功能分类：
	    内连接：
		等值连接
		非等值连接
		自连接
	     外连接：
		左外连接
		右外连接
		全外连接
	     交叉连接

*/
SELECT 
  * 
FROM
  beauty ;

SELECT 
  * 
FROM
  boys ;

SELECT 
  `name`,
  `boyName` 
FROM
  beauty,
  boys 
WHERE beauty.`boyfriend_id` = boys.`id` ;
   ```

   - sql192标准

     - 内连接

       ```mysql
       # 一、sql92标准
       # 1. 等值连接
       /*
       ①多表等值连接的结果为多表的交集部分
       ②n表连接，至少需要n-1个连接条件
       ③多表连接的顺序没有要求
       ④一般需要为表起别名
       ⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选
       */
       # 案例1：查询所有女神名和对应的男神名
       SELECT 
         `name`,
         boyname 
       FROM
         beauty,
         boys 
       WHERE beauty.boyfriend_id = boys.id ;
       
       # 案例2：查询员工名和对应的部门名
       SELECT 
         last_name,
         department_name 
       FROM
         employees,
         departments 
       WHERE employees.`department_id` = departments.`department_id` ;
       
       # 1.2为表起别名
       /*
       ①提高语句的简洁度
       ②区分多个重名的字段
       
       注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定
       
       */
       # 案例：查询员工名、工种号、工种名
       SELECT 
         last_name,
         e.job_id,
         job_title 
       FROM
         employees AS e,
         jobs AS j 
       WHERE e.`job_id` = j.`job_id` ;
       
       # 1.3 两个表的顺序是否可以调换
       # 案例：查询员工名、工种号、工种名
       SELECT 
         last_name,
         e.job_id,
         job_title 
       FROM
         jobs AS j,
         employees AS e 
       WHERE e.`job_id` = j.`job_id` ;
       
       # 1.4 可以加筛选？
       # 案例1：查询有奖金的员工名、部门名
       SELECT 
         last_name,
         department_name 
       FROM
         employees AS e,
         departments AS d 
       WHERE e.`department_id` = d.`department_id` 
         AND e.`commission_pct` IS NOT NULL ;
       
       # 案例2：查询城市名中第二个字符为o的部门名和城市名
       SELECT 
         department_name,
         city 
       FROM
         departments AS d,
         locations AS l 
       WHERE d.`location_id` = l.`location_id` 
         AND city LIKE '_o%' ;
       
       # 1.5 可以加分组？
       # 案例1：查询每个城市的部门个数
       SELECT 
         city,
         COUNT(*) 
       FROM
         departments AS d,
         locations AS l 
       WHERE d.`location_id` = l.`location_id` 
       GROUP BY city ;
       
       # 案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资
       SELECT 
         department_name,
         d.manager_id,
         MIN(salary) 
       FROM
         departments AS d,
         employees AS e 
       WHERE d.`department_id` = e.`department_id` 
         AND e.`commission_pct` IS NOT NULL 
       GROUP BY department_name,
         d.manager_id ;
       
       # 1.6 可以加排序？
       # 案例：查询每个工种名和员工个数，并且按照员工个数降序
       SELECT 
         job_title,
         COUNT(*) 
       FROM
         jobs AS j,
         employees AS e 
       WHERE j.`job_id` = e.`job_id` 
       GROUP BY job_title 
       ORDER BY COUNT(*) DESC ;
       
       # 1.7 可以实现三表连接？
       # 案例：查询员工名、部门名和所在的城市
       SELECT 
         last_name,
         department_name,
         city 
       FROM
         employees AS e,
         departments AS d,
         locations AS l 
       WHERE e.`department_id` = d.`department_id` 
         AND d.`location_id` = l.`location_id` ;
       
       # 2.非等值连接
       # 案例2：查询员工的工资和工资级别
       /*CREATE TABLE job_grades
       (grade_level VARCHAR(3),
        lowest_sal  int,
        highest_sal int);
       
       INSERT INTO job_grades
       VALUES ('A', 1000, 2999);
       
       INSERT INTO job_grades
       VALUES ('B', 3000, 5999);
       
       INSERT INTO job_grades
       VALUES('C', 6000, 9999);
       
       INSERT INTO job_grades
       VALUES('D', 10000, 14999);
       
       INSERT INTO job_grades
       VALUES('E', 15000, 24999);
       
       INSERT INTO job_grades
       VALUES('F', 25000, 40000);*/
       # select * from job_grades;
       SELECT 
         salary,
         grade_level 
       FROM
         employees AS e,
         job_grades AS j 
       WHERE salary >= j.`lowest_sal` 
         AND salary <= j.`highest_sal` ;
       
       # 3. 自连接
       # 案例：查询员工名和上级的名称
       SELECT 
         a.last_name AS 上级,
         b.last_name AS 员工 
       FROM
         employees AS a,
         employees AS b 
       WHERE a.`employee_id` = b.`manager_id` ;
       ```

       - 测试题

         ```mysql
         # 测试题
         # 1. 显示员工表的最高工资、平均工资 
         SELECT 
           MAX(salary),
           AVG(salary) 
         FROM
           employees ;
         
         # 2. 查询员工表的employee_id、job_id、last_name,按照depertment_id降序，salary升序
         SELECT 
           employee_id,
           job_id,
           last_name 
         FROM
           employees 
         ORDER BY department_id DESC,
           salary ASC ;
         
         # 3. 查询员工表的job_id中包含 a和e的，并且a在e前面
         SELECT 
           job_id 
         FROM
           employees 
         WHERE job_id LIKE '%a%e%' ;
         
         /*4. 已知表student，里面有id(学号)、name、gradeId(年级编号)
              已知表grade，里面有id(年级编号)、name(年级名)
              已知表result，里面有id、score、studentNo(学号)
              要求查询姓名、年级名、学号*/
         SELECT 
           student.name,
           grade.name,
           studentNo 
         FROM
           student,
           grade,
           result 
         WHERE student.gradeId = grade.id 
           AND student.id = result.studentNo ;
         
         # 5. 显示当前日期，以及去前后空格，截取子字符串的函数
         SELECT 
           NOW() ;
         
         SELECT 
           TRIM(
             ' ' FROM ' 哈哈哈哈哈哈哈       '
           ) ;
         
         SELECT 
           SUBSTR('  哈哈哈哈哈哈哈  ', 5, 8) ;
         ```
         
        - 测试题
       
          ```mysql
          # 测试题
          # 1. 显示所有员工的姓名、部门号和部门名称
          SELECT 
            last_name,
            e.department_id,
            department_name 
          FROM
            employees AS e,
            departments AS d 
          WHERE e.`department_id` = d.`department_id` ;
          
          # 2. 查询90号部门员工的job_id和90号部门的location_id
          SELECT 
            job_id,
            location_id,
            e.department_id 
          FROM
            employees AS e,
            departments AS d 
          WHERE e.`department_id` = d.`department_id` 
            AND e.department_id = 90 ;
          
          # 3. 选择所有奖金的员工的 last_name、department_name,location_id,city
          SELECT 
            e.last_name,
            d.department_name,
            l.location_id,
            l.city 
          FROM
            employees AS e,
            departments AS d,
            locations AS l 
          WHERE e.`department_id` = d.`department_id` 
            AND d.`location_id` = l.`location_id` 
            AND e.`commission_pct` IS NOT NULL ;
          
          # 4. 选择city在Toronto工作的员工的 last_name、job_id、department_id、department_name
          SELECT 
            e.last_name,
            e.job_id,
            e.department_id,
            d.department_name 
          FROM
            employees AS e,
            departments AS d,
            locations AS l 
          WHERE e.`department_id` = d.`department_id` 
            AND d.`location_id` = l.`location_id` 
            AND l.`city` = 'Toronto' ;
          
          # 5. 查询每个工种、每个部门的部门名、工种名和最低工资
          SELECT 
            e.job_id,
            d.department_name,
            j.job_title,
            MIN(e.salary) 
          FROM
            employees AS e,
            departments AS d,
            jobs AS j 
          WHERE e.`department_id` = d.`department_id` 
            AND e.`job_id` = j.`job_id` 
          GROUP BY e.job_id,
            d.department_name ;
          
          # 6. 查询每个国家下的部门个数>2的国家编号
          SELECT 
            `country_id`,
            COUNT(*) 
          FROM
            locations AS l,
            departments AS d 
          WHERE l.`location_id` = d.`location_id` 
          GROUP BY `country_id` 
          HAVING COUNT(*) > 2 ;
          
          # 7. 选择指定员工的姓名、员工号，以及他的管理者的姓名和员工名，结果类似于下面的格式
          # employees     Emp#    manager Mgr#
          # Kochhar       101     king    100
          SELECT 
            a.last_name AS employees,
            a.employee_id AS `Emp#`,
            b.`last_name` AS manager,
            b.employee_id AS Mgr #
          FROM
            `employees` AS a,
            `employees` AS b 
          WHERE b.`employee_id` = a.`manager_id` 
            AND a.last_name = 'Kochhar' ;
          ```
     
   - sql199标准

     ```mysql
     # 二、sql99标准
     /*
     语法：
     	select 查询列表
     	from 表1 as 别名 【连接类型】
     	join 表2 as 别名
     	on 连接条件
     	【where 筛选条件】
     	【group by 分组】
     	【having 筛选条件】
     	【order by 排序列表】;
     
     分类：
     内连接(✦)：inner
     外连接
     	左外(✦)：left 【outer】
     	右外(✦)：right【outer】
     	全外：full【outer】
     交叉连接：cross
     */
     ```

     - 内连接

       ```mysql
       # 1. 内连接
       /*
       语法：
       select 查询列表
       form 表1 别名
       inner join 表2 别名
       on 连接条件;
       
       分类：
       等值
       非等 
       自连接
       
       特点：
       ①添加排序、分组、筛选
       ②inner可以省略
       ③筛选体哦阿健放在where后面，连接条件放在on的后面，提高分离性，便于阅读
       ④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集
       
       */
       # 1.1 等值连接
       # 案例1：查询员工名、部门名
       SELECT 
         last_name,
         department_name 
       FROM
         employees AS e 
         INNER JOIN departments AS d 
           ON e.`department_id` = d.`department_id` ;
       
       # 案例2： 查询名字中包含e的员工名和工种名(筛选)
       SELECT 
         last_name,
         job_title 
       FROM
         employees AS e 
         INNER JOIN jobs AS j 
           ON e.`job_id` = j.`job_id` 
       WHERE last_name LIKE '%e%' ;
       
       # 案例3：查询部门个数>3的城市名和部门个数(添加分组和筛选)
       SELECT 
         city,
         COUNT(*) 
       FROM
         locations AS l 
         INNER JOIN departments AS d 
           ON d.`location_id` = l.`location_id` 
       GROUP BY city 
       HAVING COUNT(*) > 3 ;
       
       # 案例4：查询哪个部门的部门员工个数>3的部门名和员工个数，并按个数降序(排序)
       SELECT 
         department_name,
         COUNT(*) 
       FROM
         departments AS d 
         INNER JOIN employees AS e 
           ON d.`department_id` = e.`department_id` 
       GROUP BY d.`department_id` 
       HAVING COUNT(*) > 3 
       ORDER BY COUNT(*) DESC ;
       
       # 案例5：查询员工名、部门名、工种名，并按部门名降序
       SELECT 
         last_name,
         department_name,
         job_title 
       FROM
         employees AS e 
         INNER JOIN departments AS d 
           ON e.`department_id` = d.`department_id` 
         INNER JOIN jobs AS j 
           ON e.`job_id` = j.`job_id` 
       ORDER BY department_name DESC ;
       
       # 1.2 非等值连接
       # 案例1：查询员工的工资级别
       SELECT 
         salary,
         grade_level 
       FROM
         employees AS e 
         JOIN job_grades AS g 
           ON e.`salary` BETWEEN g.`lowest_sal` 
           AND g.`highest_sal` ;
       
       # 案例2：查询每个工资级别的个数>20的个数，并按工资级别降序
       SELECT 
         grade_level,
         COUNT(*) 
       FROM
         employees AS e 
         JOIN job_grades AS g 
           ON e.`salary` BETWEEN g.`lowest_sal` 
           AND g.`highest_sal` 
       GROUP BY grade_level 
       HAVING COUNT(*) > 20 ;
       
       # 1.3 自连接
       # 案例1：查询员工名和他上级的名字
       SELECT 
         a.last_name AS 上,
         b.last_name 
       FROM
         employees AS a 
         JOIN employees AS b 
           ON b.`manager_id` = a.`employee_id` ;
       
       
       # 案例2：查询姓名中包含k的员工名和他上级的名字
       SELECT 
         a.last_name AS 上,
         b.last_name 
       FROM
         employees AS a 
         JOIN employees AS b 
           ON b.`manager_id` = a.`employee_id` 
       WHERE b.`last_name` LIKE '%k%' ;
       ```

     - 外连接

       ```mysql
       # 2. 外连接
       /*
       应用场景：用于查询一个表中有，另一个表中没有的记录
       
       特点：
       1. 外连接的查询结果为主表中的所有记录
       	如果从表中有和他匹配的，则显示匹配的值
       	如果从表中有没和他匹配的，则显示null
       	外连接查询结果=内连接结果+主表中有而从表中没有的记录
       2. 左外连接，left join 左边的是主表
          右外连接，right join 右边的是从表
       3. 左外和右外交换两个表的顺序，可以实现同样的效果
       4. 全外连接=内连接的结果+表1中有但表2中没有的+表2中有但表1中没有的
       */
       # 引入：查询男朋友不在男神表中的女神
       
       SELECT * FROM beauty;
       SELECT * FROM boys;
       
       SELECT 
         b.name,
         bo.* 
       FROM
         beauty AS b 
         LEFT OUTER JOIN boys AS bo 
           ON b.`boyfriend_id` = bo.`id` 
       WHERE bo.`id` IS NULL ;
       
       SELECT 
         b.name,
         bo.* 
       FROM
         boys AS bo 
         RIGHT OUTER JOIN beauty AS b 
           ON b.`boyfriend_id` = bo.`id` 
       WHERE bo.`id` IS NULL ;
       
       SELECT 
         b.*,
         bo.* 
       FROM
         boys AS bo 
         LEFT OUTER JOIN beauty AS b 
           ON b.`boyfriend_id` = bo.`id` ;
           
           
       # 案例1：那个部门没有员工
       # 左外
       SELECT 
         d.*,
         e.employee_id 
       FROM
         departments AS d 
         LEFT OUTER JOIN employees AS e 
           ON d.`department_id` = e.`department_id` 
       WHERE e.`employee_id` IS NULL ;
       
       # 右外
       SELECT 
         d.*,
         e.employee_id 
       FROM
         employees AS e 
         RIGHT OUTER JOIN departments AS d 
           ON d.`department_id` = e.`department_id` 
       WHERE e.`employee_id` IS NULL ;
       
       # 全外
       
       USE girls;
       SELECT 
         b.*,
         bo.* 
       FROM
         beauty AS b 
         LEFT OUTER JOIN boys AS bo 
           ON b.`boyfriend_id` = bo.`id` ;
       ```

     - 交叉连接

       ```mysql
       # 3. 交叉连接
       SELECT b.*,bo.*
       FROM beauty AS b
       CROSS JOIN boys bo;
       ```

     - 测试题

       ```mysql
       # 测试题
       # 1. 查询编号>3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充
     SELECT 
         b.id,
         b.name,
         bo.* 
       FROM
         beauty AS b 
         LEFT OUTER JOIN boys AS bo 
           ON b.`boyfriend_id` = bo.`id` 
       WHERE b.`id` > 3 ;
       
       # 2. 查询那个城市没有部门
       SELECT 
         city,
         department_name 
       FROM
         locations AS l 
         LEFT OUTER JOIN departments AS d 
           ON l.`location_id` = d.`location_id` 
       WHERE department_name IS NULL ;
       
       # 3. 查询部门名为SAL或IT的员工信息
       SELECT 
         d.department_name,
         e.* 
       FROM
         departments AS d 
         LEFT OUTER JOIN employees AS e 
           ON d.`department_id` = e.`department_id` 
       WHERE d.`department_name` = 'SAL' 
         OR d.`department_name` = 'IT' ;
       
       # 或者
       SELECT 
         d.department_name,
         e.* 
       FROM
         departments AS d 
         LEFT OUTER JOIN employees AS e 
           ON d.`department_id` = e.`department_id` 
       WHERE d.`department_name` IN ('SAL', 'IT') ;
       ```
       
       

   - 总结

     ```mysql
     # sql92 和 sql99
     
     # 功能：sql99支持的较多
     # 可读性：sql99实现连接条件和筛选条件的分离，可读性较高
     ```

     - 内连接

       ![image-20201012112224618](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201012112224618.png)

     - 左外连接

       ![image-20201012112303456](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201012112303456.png)

     - 右外连接

       ![image-20201012112335222](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201012112335222.png)

     - 外连接加条件

       ![image-20201012112422097](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201012112422097.png)

     - 全外连接

       ![image-20201012112623360](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201012112623360.png)

### 复习：DQL语言-排序查询★

- 复习：DQL语言-排序查询

    - 语法

        ```mysql
        select 查询列表
        from 表
        where 筛选条件
        order by 排序列表【asc|desc】
        ```

    - 特点：

        - asc：升序【默认升序】

          desc：降序

        - 排序列表 支持 单个字段、多个字段、函数、表达式、别名

        - order by的位置一般放在查询语句的最后(除limit语句之外)

### 复习：DQL语言-常见函数★

- 复习：DQL语言-常见函数

    - 概述

        - 功能：类似于java中的方法
        - 好处：提高重用性和隐藏的实现细节
        - 调用：select 函数名(实参列表)

    - 单行函数

        - 字符函数

            concat：拼接字符

            substr：截取字符

            upper：大写

            lower：小写

            replace：替换

            length：取长度

            trim：去前后空格

            lpad：左填充

            rpad：又填充

            instr：获取子串第一次出现的索引

        - 数学函数

            round：四舍五入

            floor：向下取整

            ceil：向上取整

            mod：取模==>取余？

            truncate：截断

            rand：获取随机数(返回0~1之间的小数)

        - 日期函数

            now：返回当前系统日期+时间

            year：返回年

            month：返回月

            day：返回日

            hour：返回小时

            minute：返回分钟

            second：返回秒

            date_format：将日期转换成字符

            str_to_date：将字符转换成日期

            curdata：返回当前系统日期

            curtime：返回当前系统时间

            datediff：返回两个日期相差的天数

            monthname：以英文形式返回月

        - 其他函数

            version：当前数据库服务器的版本

            database：当前打开的数据库

            user：当前用户

            password('字符')：返回该字符的密码形式

            md5('字符')：返回md5加密形式

        - 流程控制函数

            if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1.否则返回表达式2

            case情况1：

            ​	case	变量或表达式或字段

            ​	when	常量1	than	值1

            ​	when	常量2	than	值2

            ​	……

            ​	else	值n

            ​	end

            case情况2：

            ​	case

            ​	when	条件1	than	值1

            ​	when	条件2	than	值2

            ​	……

            ​	else	值n

            ​	end
        
    - 分组函数

        - 分类

            max：最大值

            min：最小值

            sum：总和

            avg：平均值

            sount：计算个数

        - 特点

            - 语法

              ```mysql
              select max(字段) form 表名;
              ```

            - 支持的类型

              sum和avg一般都用于处理数据

              max、sin、count可以处理任何数据类型

            - 以上分组函数均忽略null

            - 都可以搭配distinct使用，实现去重的统计

              ```mysql
              select sum(distinct 字段) from 表名
              ```

            - count函数

              ```mysql
              # count(字段)：统计该字段非空值的个数
              # count(*)：统计结果集的行数
              # count(1)：统计结果集的行数
              
              # 效率上：
              #	MyISAM存储引擎，count(*)最高
              #	InnoDB存储引擎，count(*)和count(1)一样
              ```

            - 和分组函数一起查询的字段，要求group by后出现的字段

### 复习：DQL语言-分组查询★

- 复习：DQL语言-分组查询

    - 语法

        ```mysql
        select 分组函数,分组后的字段
        from 表
        【where 筛选条件】
        group by 分组的字段
        【having 分组后的筛选】
        【order by 排序列表】
        ```

        

    - 特点

        |            | 使用关键字 | 筛选的表     | 位置            |
        | ---------- | ---------- | ------------ | --------------- |
        | 分组前筛选 | where      | 原始表       | group by 的前面 |
        | 分组后筛选 | having     | 分组后的结果 | group by 的后面 |

### 复习：DQL语言-连接查询★

- 复习：DQL语言-连接查询

    - 含义

        ```mysql
        # 当查询中涉及到多个表的字段，需要使用多表连接
        select 字段1，字段2
        from 表1，表2……
        # 笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接
        # 如何避免：添加有效的连接条件
        ```

    - 分类

        - 按年代分类

          - sql92

            - 内连接

              等值连接
              非等值连接
              自连接

          - sql99【推荐使用】

            - 内连接

              等值连接
              非等值连接
              自连接

            - 外连接

              左外连接
              右外连接
              全外连接

            - 交叉连接

              

    - sql92语法

        - 等值连接

            - 语法：

                ```mysql
                select 查询列表
                from 表1，表2
                where 表1.key = 表2.key
                【and 筛选条件】
                【group by 分组字段】
                【having 筛选条件】
                【order by 排序字段】
                ```

            - 特点：

                - 一般为表起别名
                - 多表的顺序可以调换
                - n表连接至少需要n-1个连接条件
                - 等值连接的结果时多表的交集部分

        - 非等值连接

            - 语法

                ```mysql
                select 查询列表
                from 表1，表2
                where 非等值得连接条件
                【and 筛选条件】
                【group by 分组字段】
                【having 筛选条件】
                【order by 排序字段】
                ```

        - 自连接

            - 语法

                ```mysql
                select 查询列表
                from 表1 别名1，表 别名2
                where 别名1.key = 别名2.key
                【and 筛选条件】
                【group by 分组字段】
                【having 筛选条件】
                【order by 排序字段】
                ```

                

    - sql99语法

        - 内连接

          - 语法：

            ```mysql
            select 查询列表
            from 表1 别名1
            【inner】 join 表 别名2
            on 别名1.key = 别名2.key
            where 筛选条件
            group by 分组字段
            having 筛选条件
            order by 排序字段
            limit 子句;
            ```

          - 特点：

            - 表的顺序不分主次
            - 内连接的结果=多表的交集
            - n表连接至少需要n-1个连接条件

          - 分类：

            - 等值连接
            - 非等值连接
            - 自连接

        - 外连接

          - 语法：

            ```mysql
            select 查询列表
            from 表1 别名1
            right|left|full【outer】 join 表 别名2
            on 别名1.key = 别名2.key
            where 筛选条件
            group by 分组字段
            having 筛选条件
            order by 排序字段
            limit 子句;
            ```

          - 特点：

            - 查询结果=主表中的所有行，如果从表和他匹配的将显示匹配行，如果没有就显示null

            - left join 左边的就是主表

              right join 右边的就是主表

              full join 两边都是主表

            - 一般用于查询除了交集部分的剩余不匹配行

        - 交叉连接

          - 语法：

            ```mysql
            select 查询列表
            from 表1 别名
            cross join 表2 别名;
            ```

          - 特点：

            类似于笛卡尔乘积

### 进阶7：子查询

```mysql
# 进阶7：子查询
/*
含义：
出现在其他语句中的select语言，成为子查询或内查询
外部的查询语句，成为主查询或外查询

分类：
按子查询出现的位置：
  select后面：
    仅支持标量子查询
  from后面：
    支持表子查询
  where或having后面 ✦：
    标量子查询(单行) ✓
    列子查询  (多行) ✓
    行子查询
  exists后面(相关子查询)：
    表子查询
按结果集的行列数不同：
  标量子查询(结果集只有一行一列)
  列子查询(结果集只有一列多行)
  行子查询(结果集一般为多行多列)
*/
```

- where或having后面

  ```mysql
  # 1.where或having后面
  /*
  1 表查询(单行子查询)
  2 列子查询(多行子查询)
  3 行子查询(多列多行)
  
  特点：
  ①子查询在括号内
  ②子查询一般放在条件右侧
  ③标量子查询，一般搭配单行操作符使用
  > < >= <= = <>
  列子查询：一般搭配多行操作符使用
  in、any/some、all
  ④子查询的执行优先于主查询执行，主查询的条件用了子查询的结果
  */
  # 1.1 标量子查询
  # 案例1：谁的工资比Abel高？
  SELECT 
    * 
  FROM
    employees 
  WHERE salary > 
    (SELECT 
      salary 
    FROM
      employees 
    WHERE last_name = 'Abel') ;
  
  # 案例2：返回job_id与141号员工相同，salary比143号员工多的员工姓名、job_id和工资
  SELECT 
    last_name,
    job_id,
    salary 
  FROM
    employees 
  WHERE job_id = 
    (SELECT 
      job_id 
    FROM
      employees 
    WHERE employee_id = '141') 
    AND salary > 
    (SELECT 
      salary 
    FROM
      employees 
    WHERE employee_id = '143') ;
  
  # 案例3：返回公司工资最少的员工的last_name,job_id和salary
  SELECT 
    last_name,
    job_id,
    salary 
  FROM
    employees 
  WHERE salary = 
    (SELECT 
      MIN(salary) 
    FROM
      employees) ;
  
  # 案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资
  SELECT 
    employee_id,
    salary 
  FROM
    employees 
  GROUP BY department_id 
  HAVING MIN(salary) > 
    (SELECT 
      MIN(salary) 
    FROM
      employees 
    WHERE department_id = '50') ;
  
  # 1.2 列子查询(多行子查询)
  # 案例1：返回locayion_id是1400或1700的部门中的所有员工姓名
  SELECT 
    last_name 
  FROM
    employees 
  WHERE department_id IN 
    (SELECT 
      department_id 
    FROM
      departments AS d 
    WHERE d.`location_id` IN ('1400', '1700')) ;
  
  # 案例2：返回其他工种中比job_id为'IT_PROG'工种任一工资低的员工：工号、姓名、job_id以及salary
  SELECT 
    employee_id,
    last_name,
    job_id,
    salary 
  FROM
    employees 
  WHERE salary < SOME 
    (SELECT 
      salary 
    FROM
      employees 
    WHERE job_id = 'IT_PROG') 
    AND job_id != 'IT_PROG' ;
  
  # 或者
  SELECT 
    employee_id,
    last_name,
    job_id,
    salary 
  FROM
    employees 
  WHERE salary < 
    (SELECT 
      MAX(salary) 
    FROM
      employees 
    WHERE job_id = 'IT_PROG') 
    AND job_id != 'IT_PROG' ;
  
  # 案例3：返回其他工种中比job_id为'IT_PROG'工种所有工资低的员工：工号、姓名、job_id以及salary
  SELECT 
    employee_id,
    last_name,
    job_id,
    salary 
  FROM
    employees 
  WHERE salary < ALL 
    (SELECT 
      salary 
    FROM
      employees 
    WHERE job_id = 'IT_PROG') 
    AND job_id != 'IT_PROG' ;
  
  # 或者
  SELECT 
    employee_id,
    last_name,
    job_id,
    salary 
  FROM
    employees 
  WHERE salary < 
    (SELECT 
      MIN(salary) 
    FROM
      employees 
    WHERE job_id = 'IT_PROG') 
    AND job_id != 'IT_PROG' ;
  
  # 1.3 行子查询(结果集一行多列或多行多列)
  # 案例：查询员工编号最小并且工资最高的员工信息
  SELECT 
    * 
  FROM
    employees 
  WHERE (employee_id, salary) = 
    (SELECT 
      MIN(employee_id),
      MAX(salary) 
    FROM
      employees) ;
  ```

- select后面

  ```mysql
  # 2. select后面
  /*
  仅仅支持标量子查询
  */
  # 案例1：查询每个部门的员工个数
  SELECT 
    d.*,
    (SELECT 
      COUNT(*) 
    FROM
      employees AS e 
    WHERE e.department_id = d.`department_id`) AS 个数 
  FROM
    departments AS d ;
  
  # 案例2：查询员工号=102的部门名
  SELECT 
    (SELECT 
      department_name 
    FROM
      departments AS d 
      JOIN employees AS e 
        ON e.department_id = d.department_id 
    WHERE e.employee_id = 102) AS 部门名 ;
  ```

- from后面

  ```mysql
  # 3.from后面
  /*
  将子查询结果集充当一张表，必须起别名
  */
  # 案例：查询每个部门的平均工资的工资等级
  SELECT 
    ag_dep.*,
    b.`grade_level` 
  FROM
    (SELECT 
      AVG(salary) AS ag,
      department_id 
    FROM
      employees 
    GROUP BY department_id) AS ag_dep 
    JOIN job_grades AS b 
      ON ag_dep.ag BETWEEN lowest_sal 
      AND highest_sal ;
  ```

-  exists后面(相关子查询)

  ```mysql
  # 4. exists后面(相关子查询)
  /*
  语法：
  exists(完整的查询语句)
  结果：1或0
  */
  SELECT 
    EXISTS 
    (SELECT 
      employee_id 
    FROM
      employees) ;
  
  # 案例1：查询有员工的部门名
  SELECT 
    department_name 
  FROM
    departments AS d 
  WHERE EXISTS 
    (SELECT 
      * 
    FROM
      employees AS e 
    WHERE d.`department_id` = e.`department_id`) ;
  
  # 案例2：查询没有女朋友的男神信息
  SELECT 
    * 
  FROM
    boys AS bo 
  WHERE NOT EXISTS 
    (SELECT 
      * 
    FROM
      beauty AS b 
    WHERE bo.`id` = b.`boyfriend_id`) ;
  ```

- 测试题

  ```mysql
  # 测试题
  # 1. 查询和Zlotkey相同部门的员工姓名和工资
  SELECT 
    last_name,
    salary,
    department_id 
  FROM
    employees AS e 
  WHERE e.`department_id` = 
    (SELECT 
      department_id 
    FROM
      employees AS b 
    WHERE b.`last_name` = 'Zlotkey') ;
  
  # 2. 查询工资比公司平均工资高的员工的员工号、姓名和工资
  SELECT 
    employee_id,
    last_name,
    salary 
  FROM
    employees AS e 
  WHERE salary > 
    (SELECT 
      AVG(salary) 
    FROM
      employees) ;
  
  # 3. 查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资
  SELECT 
    e.department_id,
    employee_id,
    last_name,
    salary,
    b.av 
  FROM
    employees AS e 
    JOIN 
      (SELECT 
        department_id,
        AVG(salary) AS av 
      FROM
        employees 
      GROUP BY department_id) AS b 
      ON e.`department_id` = b.`department_id` 
  WHERE e.salary > b.av ;
  
  # 4. 查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名
  SELECT 
    employee_id,
    last_name 
  FROM
    employees AS e 
  WHERE e.`department_id` IN 
    (SELECT 
      department_id 
    FROM
      employees 
    WHERE last_name LIKE '%u%') ;
  
  # 5. 查询在部门的location_id为1700的部门工资的员工的员工号
  SELECT 
    employee_id 
  FROM
    employees 
  WHERE department_id IN 
    (SELECT 
      department_id 
    FROM
      departments AS d 
    WHERE d.`location_id` = '1700') ;
  
  # 6. 查询管理者是king的员工姓名和工资
  SELECT 
    last_name,
    salary 
  FROM
    employees 
  WHERE manager_id IN 
    (SELECT 
      employee_id 
    FROM
      employees 
    WHERE last_name = 'K_ing') ;
  
  # 7. 查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓、名
  SELECT 
    CONCAT(first_name, last_name) AS 姓、名 
  FROM
    employees 
  WHERE salary = 
    (SELECT 
      MAX(salary) 
    FROM
      employees) ;
  ```

  

### 进阶8：分页查询✦

```mysql
# 进阶8：分页查询
/*
应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求
语法：
	select 查询列表
	from 表
	【join type join 表2
	on 连接查询
	where 查询条件
	group by 排序的字段
	having 分组后的筛选
	order by 排序的字段】
	limit offset,size;
	
	offset：要显示条目的起始索引(起始索引从0开始)
	size：要显示的条目个数
特点：
	①limit语句放在查询语句的最后
	②公式：
	要显示的页数page，每页的条目数size
	
	select 查询列表
	from 表
	limit page*size,size;
	
	page(页数) offset(索引) size(条数)
	1          0            10
	2	   	   10		    10
	3	       20 		    10
	n	       (n-1)*size	10	
*/
# 案例1：查询前五条员工的信息
SELECT 
  * 
FROM
  employees 
LIMIT 0, 5 ;

SELECT 
  * 
FROM
  employees 
LIMIT 5 ;

# 案件2：查询第11条到第25条
SELECT 
  * 
FROM
  employees 
LIMIT 10, 15 ;

# 案例3：有奖金的员工信息，并且工资较高的前10名显示出来
SELECT 
  * 
FROM
  employees 
WHERE commission_pct IS NOT NULL 
ORDER BY salary DESC 
LIMIT 10 ;
```

- 测试题

    ```mysql
    # 测试题
    /*
    已知表 stuinfo
    id 		学号
    name 		姓名
    email 		邮箱
    gradeId 	年级编号
    sex 		性别
    age 		年龄
    
    已知表 grade
    id		年级编号
    gradeName	年级名称
    */
    # 1. 查询所有学员的邮箱用户名(注：邮箱中@前面的字符)
    SELECT 
      SUBSTR(email, 1, INSTR(email, '@')) 
    FROM
      stuinfo ;
    
    # 2. 查询男生和女生的个数
    SELECT 
      sex,
      COUNT(*) 
    FROM
      stuinfo 
    GROUP BY sex ;
    
    # 3. 查询年龄>18岁的所有姓名和年级名称
    SELECT 
      `name`,
      gradeName 
    FROM
      stuinfo AS s 
      JOIN grade AS g 
        ON s.gradeId = g.id 
    WHERE s.age > 18 ;
    
    # 4. 查询那个年级的学生最小年龄>20岁
    SELECT 
      *,
      MIN(age) AS dage 
    FROM
      stuinfo 
    GROUP BY gradeId 
    HAVING dage > 20 ;
    
    # 5. 试说出查询语句涉及到的所有关键字，以及执行先后顺序
    /*
    ⑦ SELECT 查询列表
    ① FROM 表1 别名1
    ② 连接类型[INNER|RIGHT|LEFT|CROSS]-[OUTER]JOIN 表2 别名2
    ③ ON 连接条件
    ④ WHERE 筛选条件
    ⑤ GROUP BY 分组列表
    ⑥ HAVING 分组后筛选条件
    ⑧ ORDER BY 排序列表
    ⑨ LIMIT 偏移，条目数
    */
    ```

### 复习：DQL语言-子查询

- 复习：DQL语言-子查询

    - 含义

        嵌套在其他语句内部的select语句被称为子查询或内查询

        外面的预计可以是insert、update、delete、select等，一般select作为外面语句较多

        外面如果为select语句，则此语句被称为外查询或主查询

    - 分类

        - 按出现位置：

            - select后面

                仅标量子查询

            - from后面

                表子查询

            - where或having后面

                标量子查询

                列子查询

                行子查询

            - exists后面

                标量子查询

                列子查询

                行子查询

                表子查询

        - 按结果集的行列

            - 标量子查询(单行子查询)：一行一列
            - 列子查询(多行子查询)：多行单列
            - 行子查询：多行多列
            - 表子查询：多行多列、一行一列、多行一列等等

    - 示例

        - where 或 having

            - 标量子查询

                ```mysql
                # 案例：查询最低工资的员工姓名和工资
                SELECT 
                  last_name,
                  salary 
                FROM
                  employees 
                WHERE salary = 
                  (SELECT 
                    MIN(salary) 
                  FROM
                    employees) ;
                ```

            - 列子查询

                ```mysql
                # 案例：所有是领导的员工的姓名
                SELECT 
                  last_name 
                FROM
                  employees 
                WHERE employee_id IN 
                  (SELECT 
                    b.employee_id 
                  FROM
                    employees AS a 
                    JOIN employees AS b 
                  WHERE a.`manager_id` = b.`employee_id`);
                ```
        
    - 练习题

        ```mysql
        # 练习题-子查询
        # 1. 查询工资最低的员工信息：last_name,salary
        SELECT 
          last_name,
          salary 
        FROM
          employees 
        WHERE salary = 
          (SELECT 
            MIN(salary) 
          FROM
            employees) ;
        
        # 2. 查询平均工资最低的部门信息
        SELECT 
          * 
        FROM
          departments 
        WHERE department_id = 
          (SELECT 
            department_id 
          FROM
            employees 
          GROUP BY department_id 
          ORDER BY MIN(salary) ASC 
          LIMIT 1) ;
        
        # 3. 查询平均工资最低的部门信息和该部门的平均工资
        SELECT 
          *,
          AVG(salary) 
        FROM
          departments AS d 
          JOIN employees AS e 
            ON e.`department_id` = d.`department_id` 
        WHERE d.department_id = 
          (SELECT 
            department_id 
          FROM
            employees 
          GROUP BY department_id 
          ORDER BY MIN(salary) ASC 
          LIMIT 1) ;
        
        # 4. 查询平均工资最高的部门信息
        SELECT 
          * 
        FROM
          departments 
        WHERE department_id = 
          (SELECT 
            department_id 
          FROM
            employees 
          GROUP BY department_id 
          ORDER BY AVG(salary) DESC 
          LIMIT 1) ;
        
        # 5. 查询平均工资高于公司平均工资的部门有哪些
        SELECT 
          * 
        FROM
          departments 
        WHERE department_id IN 
          (SELECT 
            department_id 
          FROM
            employees 
          GROUP BY department_id 
          HAVING AVG(salary) > 
            (SELECT 
              AVG(salary) 
            FROM
              employees)) ;
        
        # 6. 查询出公司中所有manager的详细信息
        SELECT 
          * 
        FROM
          employees 
        WHERE employee_id IN 
          (SELECT 
            manager_id 
          FROM
            employees) ;
        
        # 7. 各个部门中，最高工资中最低的那个部门，最低工资是多少
        SELECT 
          MIN(salary) 
        FROM
          employees 
        WHERE department_id = 
          (SELECT 
            department_id 
          FROM
            employees 
          GROUP BY department_id 
          ORDER BY MAX(salary) 
          LIMIT 1) ;
        
          
        # 8. 查询平均工资最高的部门的manager的详细信息：last_name,depertmenr_id,email,salary
        SELECT 
          last_name,
          d.manager_id,
          email,
          salary 
        FROM
          employees AS e 
          JOIN departments AS d 
            ON e.`employee_id` = d.`department_id` 
        WHERE e.department_id = 
          (SELECT 
            department_id 
          FROM
            employees 
          GROUP BY department_id 
          ORDER BY AVG(salary) DESC 
          LIMIT 1) ;
        ```

### 复习：DQL语言-分页查询★

- 复习：DQL语言-分页查询

    - 应用场景

        当要查询的条目数太多。一页显示不全

    - 语法：

        ```mysql
        SELECT 
          查询列表 
        FROM
          表 【join TYPE 
          JOIN 表2 
            ON 连接查询 
        WHERE 查询条件 
        GROUP BY 排序的字段 
        HAVING 分组后的筛选 
        ORDER BY 排序的字段】 
        LIMIT offset, size ;
        
        offset：要显示条目的起始索引(起始索引从0开始)
        size：要显示的条目个数
        
        ```

        | page(页数) | offset(索引) | size(条数) |
        | ---------- | ------------ | ---------- |
        | 1          | 0            | 10         |
        | 2          | 10           | 10         |
        | 3          | 20           | 10         |
        | 4          | 30           | 10         |
        | n          | (n-1)*10     | 10         |

### 进阶9：联合查询

```mysql
# 进阶9：联合查询
/*
union 联合 合并 将多条查询语句的结果合并成一个结果
语法：
查询语句1：
union
查询语句2：
union
……

应用场景：
要查询的结果来自于多个表，且多个表中没有直接的连接关系，但查询的信息一致时

特点✦：
1.要求多条查询语句的查询列表是一致的
2.要求多条查询语句的查询的每一列的类型和顺序最好一致
3.union关键字默认去重，如果用union all可以包含重复项

*/
# 引入的案例：查询部门编号>90或者邮箱包含a的员工信息
SELECT 
  * 
FROM
  employees 
WHERE email LIKE '%a%' 
  OR department_id > 90 ;

SELECT 
  * 
FROM
  employees 
WHERE email LIKE '%a%' 
UNION
SELECT 
  * 
FROM
  employees 
WHERE department_id > 90 ;

# 案例：查询中国用户中男性的信息以及国外用户中男性的信息
SELECT 
  * 
FROM
  t_ca 
WHERE csex = '男' 
UNION
# 默认去重
SELECT 
  * 
FROM
  t_ua 
WHERE tGander = 'male' ;

SELECT 
  * 
FROM
  t_ca 
WHERE csex = '男' 
UNION
ALL # 不去重
SELECT 
  * 
FROM
  t_ua 
WHERE tGander = 'male' ;
```

### 进阶10：DML语言✦

```mysql
# DML语言
/*
数据操作语言：
插入：insert
修改：update
删除：delete

*/
# 一、插入语句
# 方式一：经典的插入
/*
语法：
insert into 表名(列名……)
values (值1……);
*/
# 1. 插入的值的类型要与列的类型一致或兼容
INSERT INTO beauty (
  id,
  `name`,
  sex,
  borndate,
  phone,
  photo,
  boyfriend_id
) 
VALUES
  (
    13,
    '唐艺昕',
    '女',
    '1990-4-23',
    '1898888888',
    NULL,
    2
  ) ;

# 2. 不可为null的列必须插入值，可以为null的列是如何插入值？
# 方式一：null
INSERT INTO beauty (
  id,
  `name`,
  sex,
  borndate,
  phone,
  photo,
  boyfriend_id
) 
VALUES
  (
    13,
    '唐艺昕',
    '女',
    '1990-4-23',
    '1898888888',
    NULL,
    2
  ) ;

# 方式二：
INSERT INTO beauty (
  id,
  NAME,
  sex,
  borndate,
  phone,
  boyfriend_id
) 
VALUES
  (
    14,
    '金星',
    '女',
    '1990-4-23',
    '1398888888',
    9
  ) ;

# 3. 列的顺序是否可以调换
INSERT INTO beauty (NAME, sex, id, phone) 
VALUES
  ('蒋欣', '女', 15, '110') ;

# 4. 列的个数和值的个数必须一致
# 5. 可以省略列名，默认是所有列，而且列的顺序和表中列的顺序一致
INSERT INTO beauty 
VALUES
  (
    16,
    '张飞',
    '男',
    NULL,
    '119',
    NULL,
    NULL
  ) ;

# 方式二：
/*
语法：
insert into 表名
set 列名1=值1,列名2=值2……
*/
INSERT INTO beauty SET id = 17,
NAME = '刘涛',
phone = '999' ;

# 两种方式大pk
# 1. 方式一支持插入多行,方式二不支持
INSERT INTO beauty 
VALUES
  (
    18,
    '唐艺昕1',
    '女',
    '1990-4-23',
    '1898888888',
    NULL,
    2
  ),
  (
    19,
    '唐艺昕2',
    '女',
    '1990-4-23',
    '1898888888',
    NULL,
    2
  ),
  (
    20,
    '唐艺昕3',
    '女',
    '1990-4-23',
    '1898888888',
    NULL,
    2
  ) ;

# 2. 方式一支持子查询，方式二不支持
INSERT INTO beauty (id, NAME, phone) 
SELECT 
  21,
  '宋茜',
  '1888' ;

INSERT INTO beauty (id, NAME, phone) 
SELECT 
  id,
  NAME,
  '1888' 
FROM
  boys 
WHERE id < 3 ;

# 二、修改语句
/*
1. 修改单表的记录✦
语法：
update 表名
set 列=新值,列=新值……
where 筛选条件
2. 修改多表的记录【补充】
语法：
sql92标准：
update 表1 别名,表2 别名
set 列 = 值……
where 连接条件
and 筛选条件

sql99标准：
update 表1 别名
inner|left|right join 表2 别名
on 连接条件
set 列 = 值……
where 筛选条件
*/
# 1. 修改单表的记录
# 案例1：修改beauty表中的姓唐的电话修改为1398888888
UPDATE 
  beauty 
SET
  phone = '1398888888' 
WHERE NAME LIKE '唐%' ;

# 案例2：修改boys表中id为2的名称为张飞，魅力值为10
UPDATE 
  boys 
SET
  boyName = '张飞',
  userCP = 999 
WHERE id = 2 ;

# 修改多表的记录
# 案例1：修改张无忌的女友的手机修改为114
UPDATE 
  boys AS bo 
  JOIN beauty AS b 
    ON bo.`id` = b.`boyfriend_id` SET phone = '114' 
WHERE bo.`boyName` = '张无忌' ;

# 案例2：修改没有男朋友的女神的男朋友的编号修改为2号
UPDATE 
  boys AS bo 
  RIGHT JOIN beauty AS b 
    ON bo.`id` = b.`boyfriend_id` SET b.`boyfriend_id` = 2 
WHERE bo.id IS NULL ;

# 三、删除语句
/*
方法一：delete
语法：
1. 单表的删除✦
delete from 表名 where 筛选条件;
2. 多表的删除【补充】
sql92标准：
delete 表1的别名,表二的别名
from 表1 别名,表2 别名
where 连接条件
and 筛选条件;

sql99标准：
delete 表1的别名,表二的别名
from 表1 别名
inner|left|right join 表2 别名
on 连接条件
where 筛选条件;


方式二：truncate
语法：
truncate table 表名;
*/
# 方式一：delete
# 1. 单表的删除
# 案例1：删除手机号以9结尾的女神信息
DELETE 
FROM
  beauty 
WHERE phone LIKE '%9' ;

# 2. 多表的删除
# 案例：删除张无忌的女朋友的信息
DELETE 
  b 
FROM
  beauty AS b 
  JOIN boys AS bo 
    ON b.`boyfriend_id` = bo.id 
WHERE bo.`boyName` = '张无忌' ;

# 案例；删除黄晓明的信息以及他女朋友的信息
DELETE 
  b,
  bo 
FROM
  beauty AS b 
  JOIN boys AS bo 
    ON bo.`id` = b.`boyfriend_id` 
WHERE bo.`boyName` = '黄晓明' ;

# 方式二：truncate语句
# 案例：清空
TRUNCATE TABLE boys ;

# delete pk truncate【面试题✦】
/*

1. delete 可以添加where条件，truncate不能添加
2. truncate 删除，效率更高
3. 假如要删除的表中有自增长列
   如果用delete删除后，在插入列的值从断点开始
   而truncate删除后，在插入数据，自增长从1开始
4. truncate删除后没返回值，delete有返回值
5. truncate删除不能回滚，delete删除可以回滚
*/
```

- 测试题

```mysql
# 测试题
# 1. 运行一下脚本创建 my_employees
/*
CREATE TABLE my_employees(
	Id INT(10),
	First_name VARCHAR(10),
	Last_name VARCHAR(10),
	Userid VARCHAR(10),
	Salary DOUBLE(10,2)
)
CREATE TABLE users(
	id INT,
	userid VARCHAR(10),
	department_id INT
)*/
USE `myemployees` ;

CREATE TABLE my_employees (
  Id INT (10),
  First_name VARCHAR (10),
  Last_name VARCHAR (10),
  Userid VARCHAR (10),
  Salary DOUBLE (10, 2)
) ;

CREATE TABLE users (
  id INT,
  userid VARCHAR (10),
  department_id INT
) ;

# 2. 显示表 my_employees 的结果
DESC my_employees ;

# 3. 向 my_employees表中插入下列数据
/*
    Id  First_name  Last_name  Userid      Salary  
------  ----------  ---------  ---------  ---------
     1  patel       Ralph      Rpatel        895.00
     2  Dancs       Brtty      Bdace         860.00
     3  Birir       Ben        Bbiri        1100.00
     4  Newman      Chad       Cnewwoman     750.00
     5  Ropeburn    Audrey     Aropebur     1550.00
*/
INSERT INTO my_employees 
VALUES
  (1, 'patel', 'Ralph', 'Rpatel', 895),
  (2, 'Dancs', 'Brtty', 'Bdace', 860),
  (3, 'Birir', 'Ben', 'Bbiri', 1100),
  (4, 'Newman', 'Chad', 'Cnewwoman', 750),
  (
    5,
    'Ropeburn',
    'Audrey',
    'Aropebur',
    1550
  ) ;

SELECT 
  * 
FROM
  my_employees ;

# 4. 向users表中插入数据
/*
    id  userid    department_id  
------  --------  ---------------
     1  Rpatel                 10
     2  Bdance                 10
     3  Bbiri                  20
     4  Cnewman                30
     5  Aropebur               40
*/
INSERT INTO users 
VALUES
  (1, 'Rpatel', 10),
  (2, 'Bdance', 10),
  (3, 'Bbiri', 20),
  (4, 'Cnewman', 30),
  (5, 'Aropebur', 40) ;

SELECT 
  * 
FROM
  users ;

# 5. 将3号员工的last_name修改成'drelxer'
UPDATE 
  my_employees 
SET
  last_name = 'drelxer' 
WHERE Id = 3 ;

# 6. 将所有工资少于900的员工的工资修改为1000
UPDATE 
  my_employees 
SET
  Salary = 1000 
WHERE Salary < 900 ;

# 7. 将userid 为 Bbiri的users表和my_employees表的记录全部删除
DELETE 
  a,
  b 
FROM
  users AS a 
  JOIN my_employees AS b 
    ON a.`userid` = b.`Userid` 
WHERE a.`userid` = 'Bbiri' ;

# 8. 删除所有数据
TRUNCATE TABLE users ;

TRUNCATE TABLE my_employees ;

# 9. 检测所作的修正
SELECT 
  * 
FROM
  my_employees ;

SELECT 
  * 
FROM
  users ;
  
# 10. 清空表my_employees
TRUNCATE TABLE my_employees ;
```

### 进阶11：DDL语言

```mysql
# 进阶11：DDL语言
/*
数据定义语言
库和表的管理
一、库的管理
创建、修改、删除
二、表的管理
创建、修改、删除

创建：create
修改：alter
删除：drop

*/
# 一、库的管理
# 1. 库的创建
/*
语法：
create database 【IF NOT EXISTS】库名;
*/
# 案例：创建库books
CREATE DATABASE IF NOT EXISTS books ;

# 2. 库的修改
# 更改库的字符集
ALTER DATABASE books 
  CHARACTER SET gbk ;

# 3. 库的删除
DROP DATABASE IF EXISTS books ;

# 二、表的管理
# 1.表的创建✦
/*
create table 表名(
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	……
	列名 列的类型【(长度) 约束】
	
)
*/
# 案例：创建表book
CREATE TABLE IF NOT EXISTS book (
  id INT,
  # 编号
  bname VARCHAR (20),
  # 书名
  price DOUBLE,
  # 价格
  authorId INT,
  # 作者编号
  publishDate DATETIME# 出版时间
) ;

CREATE TABLE IF NOT EXISTS author (
  id INT,
  au_name VARCHAR (20),
  nation VARCHAR (10)
) ;

DESC book ;

DESC author ;

# 2. 表的修改
/*
语法：
alter table 表名 add|drop|modify|change column 列名 【列类型 约束】

*/
# ①修改列名
ALTER TABLE book 
  CHANGE COLUMN publishDate pubDate DATETIME ;

# ②修改列的类型或约束
ALTER TABLE book 
  MODIFY COLUMN pubDate TIMESTAMP ;

# ③添加列
ALTER TABLE author 
  ADD COLUMN annual DOUBLE ;

# ④删除列
ALTER TABLE author 
  DROP COLUMN annual ;

# ⑤修改表名
ALTER TABLE author 
  RENAME TO book_author ;

# 表的删除
DROP TABLE IF EXISTS book_author ;

SHOW TABLES ;

# 通用的学法：
DROP DATABASE IF EXISTS 旧库名 ;

CREATE DATABASE 新库名 ;

DROP TABLE IF EXISTS 旧表名 ;

CREATE TABLE 新表名 () ;

# 3. 表的复制
INSERT INTO author 
VALUES
  (1, '村上春树', '日本'),
  (2, '莫言', '中国'),
  (3, '金庸', '中国'),
  (4, '古龙', '中国') ;

# 仅仅复制表的结构
CREATE TABLE copy1 LIKE author ;

# 复制数据的结构+数据
CREATE TABLE copy2 
SELECT 
  * 
FROM
  author ;

# 只复制部分数据
CREATE TABLE copy3 
SELECT 
  id,
  au_name 
FROM
  author 
WHERE nation = '中国' ;

# 只复制某些字段,不要数据
CREATE TABLE copy4 
SELECT 
  id,
  au_name 
FROM
  author 
WHERE 0 ;
```

- 练习题

  ```mysql
  # 练习题
  # 1. 创建表dept1
  /*
  name null? type
  id         int(7)
  name       varchar(25)
  */
  CREATE TABLE dept1 (id INT (7), NAME VARCHAR (25)) ;
  
  # 2. 将表departments中的数据插入到新表dept2中
  CREATE TABLE dept5 
  SELECT 
    * 
  FROM
    `myemployees`.departments ;
  
  # 3. 创建表emp5
  /*
  name   		null? 	type
  id			int(7)
  First_name		varchar(25)
  Last_name		carchar(25)
  dept_id			int(7)
  */
  CREATE TABLE emp5 (
    id INT (7),
    First_name VARCHAR (25),
    Last_name VARCHAR (25),
    dept_id INT (7)
  ) ;
  
  # 4. 将列Last_name的长度增加到50
  ALTER TABLE emp5 
    MODIFY COLUMN last_name VARCHAR (50) ;
  
  # 5. 根据表employees创建employees2
  CREATE TABLE employees2 LIKE `myemployees`.employees ;
  
  # 6. 删除表emp5
  DROP TABLE emp5 ;
  
  # 7. 将表employees2重命名为emp5
  ALTER TABLE employees2 
    RENAME TO emp5 ;
  
  # 8. 在表dept和emp5中添加新列test_colum,检查所作的操作
  ALTER TABLE dept 
    ADD COLUMN test_colum INT;
  
  ALTER TABLE emp5 
    ADD COLUMN test_colum INT;
  
  # 9. 直接删除表emp5中的列dept_id
  ALTER TABLE emp5 DROP COLUMN test_colum;
  ```

### 常见的数据类型

- 整型

  ![image-20201013145100066](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013145100066.png)

  ```mysql
  # 一、整型
  /*
  分类：
  tinyint、smallint、mediumint、int/integer、bigint
  1	 2	   3	      4		   8
  
  特点：
  ① 如果不设置无符号还是有符号，默认是有符号，如果设置无符号，需要添加unsigned关键字
  ② 如果插入的数值超出了整型的范围，会报out of range异常。并且插入临界值
  ③ 如果不设置长度，会有默认的长度
  长度代表显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！
  
  */
  
  # 1. 如何设置无符号和有符号
  
  CREATE TABLE tab_int(t1 INT(7),t2 INT(7) UNSIGNED);
  INSERT INTO tab_int VALUES(-123456);
  INSERT INTO tab_int VALUES(-123456,-123456);
  INSERT INTO tab_int VALUES(123,123);
  DESC tab_int;
  
  SELECT * FROM tab_int;
  ```

- 小数

  ![image-20201013151032304](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013151032304.png)

  ```mysql
  # 二、小数
  /*
  1. 浮点数
  float(M,D)
  double(M,D)
  2. 定点数
  dec(M,D)
  decimal(M,D)
  
  特点：
  ① M：整数数位+小数数位
    D：小数数位
    如果超过范围，插入临界值
  ② M和D都可以省略
    如果是decimal,则M默认为10,D默认为0
    如果是float和double，则回根据插入的数值的精度来决定精度
  ③ 定点型的精准度较高，如果要求插入的数值的精度较高要求如货币运算等则考虑使用
  */
  
  DROP TABLE tab_float;
  CREATE TABLE tab_float(
  	f1 FLOAT,
  	f2 DOUBLE,
  	f3 DECIMAL
  );
  SELECT * FROM tab_float;
  DESC tab_float;
  
  INSERT INTO tab_float VALUES(123.45,123.45,123.45);
  INSERT INTO tab_float VALUES(123.456,123.456,123.456);
  INSERT INTO tab_float VALUES(123.4,123.4,123.4);
  INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);
  ```

- 字符型

  ![image-20201013155225580](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013155225580.png)

  ![image-20201013155831606](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013155831606.png)

  ![image-20201013155904627](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013155904627.png)

  ![image-20201013160603080](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013160603080.png)

  ```mysql
  # 三、字符型
  /*
  较短的文本：
  char、varchar
  
  其他：
  binary和varbinary用于保存较短的二进制
  enum用于保存枚举
  set用于保存集合
  
  
  较长的文本：
  text、blob(较大的二进制)
  
  
  特点：	
  	写法		M的意思				特点		空间的耗费	效果
  char	char(M)		最大的字符数，可省略，默认为1	固定长度的字符	比较耗费	高
  varchar	varchar(M)	最大的字符数，不可省略		可变长度的字符	比较节省	低
  
  */
  
  
  
  CREATE TABLE tab_char(
  	c1 ENUM('a','b','c')
  );
  
  INSERT INTO tab_char VALUES('a');
  INSERT INTO tab_char VALUES('b');
  INSERT INTO tab_char VALUES('c');
  INSERT INTO tab_char VALUES('f');
  
  SELECT * FROM tab_char;
  
  CREATE TABLE tab_set(
  	c1 SET('a','b','c')
  );
  INSERT INTO tab_set VALUES('a');
  INSERT INTO tab_set VALUES('a,b');
  ```

- 日期型

  ![image-20201013161109716](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013161109716.png)

  ![image-20201013161423430](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201013161423430.png)

  ```mysql
  # 四、日期型
  /*
  分类：
  date 只保存日期
  time 只保存时间
  year 只保存年
  
  datetime 保存日期+时间
  timestamp 保存日期+时间
  
  特点：
  		字节	范围		时区等影响
  datetime	8	1000~9999	不受
  timestamp	4	1970~2038	受
  */
  
  CREATE TABLE tab_date(
  	t1 DATETIME,
  	t2 TIMESTAMP
  );
  
  INSERT INTO tab_date VALUES(NOW(),NOW());
  
  SELECT * FROM tab_date;
  
  SHOW VARIABLES LIKE 'time_zone';
  
  SET time_zone = '+8:00';
  ```

- 原则

  ```	mysql
  # 原则
  /*
  所选的类型越简单越号，能保存数值的类型越小越好
  */
  ```


### 复习：DQL语言-联合查询

- 复习：DQL语言-联合查询 

  - 含义

    union：合并、联合，将多次的查询结果合并成一个结果

  - 语法

    ```mysql
    查询语句1
    union 【all】
    查询语句2
    union 【all】
    ……
    ```

  - 意义

    - 将一条复杂的查询语句拆分成多条语句
    - 适用于查询多个表的时候，查询的列基本式基本一致

  - 特点

    - 要求多条查询语句的查询列数必须一致
    - 要求多条查询语句的查询的各列类型、顺序最好一致
    - union 去重 union all 包含重复项

### 复习：DQL语言-查询总结

- 复习：DQL语言-查询总结

  - 语法：

    ```mysql
    ⑦ select 查询列表
    ① from 表1 别名
    ② 连接类型 join 表2
    ③ on 连接条件
    ④ where 筛选条件
    ⑤ group by 分株列表
    ⑥ having 筛选条件
    ⑧ order by 排序列表
    ⑨ limit 起始条目索引，条目数；
    ```

### 复习：DML语言-插入语句★

- 复习：DML语言-插入语句

  - 方法一

    - 语法

      ```mysql
      insert into 表名(字段名……) values(值……);
      ```

    - 特点：

      - 要求值的类型和字段的类型要一致或兼容

      - 字段的个数和顺序不一定与原始表中的字段个数和顺序一致

        但必须值和字段一一对应

      - 假如表中有可以为null的字段，注意可以通过两种方式插入null值

        - 字段和值都省略
        - 字段写上，值使用null

      - 字段和值的个数必须一致

      - 字段名可以省略，默认所有列

  - 方法二

    - 语法

      ```mysql
      insert into 表名 ser 字段=值……
      ```

  - 两种方式的区别：

    - 方法一支持插入多行，语法如下

      ```mysql
      insert into 表名【(字段……)】 values(值……),(值……),(值……)……
      ```

    - 方式一支持子查询，语法如下

      ```mysql
      insert into 表名
      查询语句
      ```

### 复习：DML语言-修改语句★

- 复习：DML语言-修改语句

  - 修改单表的记录✦

    - 语法：

      ```mysql
      update 表名 set 字段=值,字段=值 【where 筛选语句】
      ```

      

  - 修改多表的记录【补充】

    - 语法：

      ```mysql
      update 表名 别名
      left|right|inner join 表2 别名
      on 连接条件
      set 字段=值,字段=值
      【where 筛选条件】
      ```

### 复习：DML语言-删除语句★

- 复习：DML语言-删除语句

  - 方法一：使用delete

    - 删除单表的记录✦

      - 语法

        ```mysql
        delete from 表名 【where 筛选条件】【limit 条目数】
        # 删除表的第一个
        delete from 表名 limit 1;
        ```

    - 级联删除【补充】

      - 语法

        ```mysql
        delete 别名1,别名2
        inner|left|right join 表2 别名
        on 连接条件
        【where 筛选条件】
        ```

  - 方法二：使用truncate

    - 语法

      ```mysql
      truncate table 表名
      ```

  - 两种方法的区别【面试题】✦

    - truncate 删除后，再插入，标识列、自增长列从1开始

      delete 删除后，再插入，标识列、自增长列从断点开始

    - delete 可以添加筛选条件

      truncate 不可以添加

    - truncate 效率较高

    - truncate 没有返回值

      delete 可以返回受影响的行数

    - truncate 不可以回滚

      delete 可以回滚

### 复习：DDL语言-库的管理

- 复习：DDL语言-库的管理
  - 创建库

    ```mysql
    create database 【if not exists】 库名 【character set 字符集名】;
    ```

  - 修改库

    ```mysql
    alter database 库名 character set 字符集名;
    ```

  - 删除库

    ```mysql
    drop database 【if exists】 库名;
    ```

### 复习：DDL语言-表的管理

- 复习：DDL语言-表的管理

  - 创建表✦

    ```mysql
    create table 【if not exists】表名(
     字段名 字段类型 【约束】,
     字段名 字段类型 【约束】,
     字段名 字段类型 【约束】,
     ……
     字段名 字段类型 【约束】
    )
    ```

  - 修改表

    - 添加列

      ```mysql
      alter table 表名 add column 列名 类型 【first|after 字段名】
      ```

    - 修改列的类型或约束

      ````mysql
      alter table 表名 modify column 列名 新类型 【新约束】;
      ````

    - 修改列名

      ```mysql
      alter table 表名 change column 旧列名 新列名 类型;
      ```

    - 删除列

      ```mysql
      alter table 表名 drop column 列名;
      ```

    - 修改表名

      ```mysql
      alter table 表名 rename column 【to】 新表名;
      ```

  - 删除表

    ```mysql
    drop table 【if exists】 表名
    ```

  - 复制表

    - 复制表的结构4

      ```mysql
      create table 表名 like 旧表;
      ```

    - 复制表的结构+数据

      ```mysql
      create table 表名
      select 查询列表 from 旧表 【where 筛选】;
      ```

### 复习：DDL语言-常见的数据类型

- 复习：DDL语言-常见的数据类型

  - 数值型

    - 整型

      ```
      tinyint samallint mediumint int/integer bigint
      1		2		  3			4			8
      ```

    - 特点

      - 都可以设置无符号和有符号，默认有符号，可通过unsigned设置无符号

      - 如果超出了范围，会报out or range 异常，插入临界值(?)

      - 长度可以不值定，默认会有一个长度

        长度代表显示的最大宽度，如果不够则左边用0填充，但需要搭配serofill，并且默认变为无符号整型

    - 浮点型

      - 定点数：decimal(M,D)
      - 浮点数:
        - float(M,D) 		4
        - double(M,D)     8
      - 特点：
        - M代表整数位数+小数位数的个数，D代表了小数位数的个数
        - 如果超出范围，则报out or range异常，并且插入临界值
        - M和D都可以省略，但对于定点数，M默认为10，D默认为0
        - 如果精度要求较高，则优先考虑使用定点数

  - 字符型

    ```mysql
    char、varchar、binary、varbinary、emum、set、text、blob
    ```

    - char：固定长度的字段

      - 写法

        ```mysql
        char(M)
        ```

        最大长度不能超过N，其中M可以省略，默认为1

    - varchar：可变长度的字符

      - 写法

        ```mysql
        varchar(M)
        ```

        最大长度不能超过N，其中M不可以省略

  - 日期型

    ```mysql
    year 年
    date 日期
    time 时间
    datetime 日期+时间 		8
    timestamp 日期+时间		4 比较容易受市区、语法模式、版本的影响，更能反映当前时区的真实时间
    ```

### 常见的约束

```mysql
# 常见约束

/*
含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性
分类：六大约束
	NOT NULL：非空，用于保证该字段的值不能为空
	比如姓名、学号等
	default：默认，用于保证该字段有默认值
	比如性别
	primary key：主键，用于保证该字段的值具有唯一性，并且非空
	unique：唯一，用于保证该字段的值具有唯一性，可以为空
	比如座位号
	check：检查约束【mysql中不支持】
	比如年龄，性别
	foreign key：外键，用于限制两个表的关系，
		用于保证该字段的值必须来自于主表的关联列的值
	比如学生表的专业编号，员工表的部门表好，员工表的工种编号
	
添加约束的时机：
	1. 创建表时
	2. 修改表时
	
约束的添加分类：
	1. 列级约束：
		六大约束语法上都支持但是外键约束没有效果
	2. 表级约束：
		除了非空、默认，其他的都支持
		
主键和唯一的大对比：
	保证唯一	是否为空	一个表可以有几个	是否允许组合
主键	✓		✗		至多1个			✓，但不推荐
唯一	✓		✓		可以有多个		✓，但不推荐

外键：
	1. 要求在从表设置为外键
	2. 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
	3. 主表的关联列必须要是一个key(一般是主键或唯一)
	4. 插入数据时，先插入主表，在插入从表
	   删除数据时，先删除从表，再删除主表
insert into major values(1,'java');
insert into major values(2,'h5');
insert into stuinfo values(1,'john','男',null,19,1);
insert into stuinfo values(2,'john','男',null,20,2);
*/

CREATE TABLE 表名(
	字段名 字段类型 列级约束,
	字段名 字段类型,
	表级约束
);

CREATE DATABASE students;
# 一、创建表时添加约束
# 1. 添加列级约束
/*
语法：
直接再字段名和类型后面追加 约束类型即可
只支持：默认、非空、主键、唯一
*/
USE students;
CREATE TABLE stuinfo(
	id INT PRIMARY KEY, # 主键
	stuName VARCHAR(20) NOT NULL, # 非空
	gender CHAR(1) CHECK(gender='男' OR gender='女'),# 检查
	seat INT UNIQUE, # 唯一约束
	age INT DEFAULT 18, # 默认约束
	majorId INT REFERENCES major(id) # 外键
);

CREATE TABLE major(
	id INT PRIMARY KEY,
	majorName VARCHAR(20)
);

DESC stuinfo;

# 查看stuinfo表中的所有索引，包括主键、外键、唯一
SHOW INDEX FROM stuinfo;

# 2. 添加表级约束
/*
语法：在各个字段的最下面
【constraint 约束名】 约束类型(字段名)
*/

DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
	id INT,
	stuName VARCHAR(20),
	gender CHAR(1),
	seat INT,
	age INT,
	majorId INT,
	
	CONSTRAINT pk PRIMARY KEY(id),# 主键
	CONSTRAINT ug UNIQUE(seat),# 唯一键
	CONSTRAINT ck CHECK(gender='男' OR gender='女'),# 检查
	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)# 外键
	
);

DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
	id INT,
	stuName VARCHAR(20),
	gender CHAR(1),
	seat INT,
	age INT,
	majorId INT,
	
	PRIMARY KEY(id),# 主键
	UNIQUE(seat),# 唯一键
	CHECK(gender='男' OR gender='女'),# 检查
	FOREIGN KEY(majorid) REFERENCES major(id)# 外键
	
);

SHOW INDEX FROM stuinfo;

DESC stuinfo;

# 通用的写法：
CREATE TABLE IF NOT EXISTS stuinfo(
	id INT PRIMARY KEY,
	stuName VARCHAR(20),
	sex CHAR(1),
	age INT DEFAULT 18,
	seat INT UNIQUE,
	majorId INT,
	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorId) REFERENCES major(id)
);

# 二、修改表时添加约束
/*
1. 添加列级约束
alter table 表名 modify column 字段名 字段类型 新约束;

2. 添加表级约束
alter table 表名 add 【constraint 约束名】约束类型(字段名)外键的引用;


*/
DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
	id INT,
	stuname VARCHAR(20),
	gender CHAR(1),
	seat INT,
	age INT,
	majorId INT	
);
DESC stuinfo;
# 1. 添加非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL;

# 2. 添加默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;

# 3. 添加主键
# ①列级约束
ALTER TABLE stuinfo MODIFY COLUMN age INT PRIMARY KEY;
# ②表级约束
ALTER TABLE stuinfo ADD PRIMARY KEY(id);

# 4. 添加唯一

# ①列级约束
ALTER TABLE stuinfo MODIFY COLUMN age INT UNIQUE;
# ②表级约束
ALTER TABLE stuinfo ADD UNIQUE(id);

# 5. 外键
ALTER TABLE stuinfo ADD FOREIGN KEY(majorid) REFERENCES major(id);

# 三、修改表时删除约束

# 1. 删除非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;
DESC stuinfo;

# 2. 删除默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT;

# 3. 删除主键
ALTER TABLE stuinfo DROP PRIMARY KEY;


# 4. 删除唯一
ALTER TABLE stuinfo DROP INDEX majorId;

# 5. 删除外键
ALTER TABLE stuinfo DROP FOREIGN KEY stuinfo_ibfk_1;

SHOW INDEX FROM stuinfo;
```

- 测试题

  ```mysql
  # 测试题
  # 1. 向表emp2的id列中添加primary key约束(my_emp_id_pk)
  ALTER TABLE emp2 MODIFY COLUMN id INT PRIMARY KEY;
  
  ALTER TABLE emp2 ADD CONSTRAINT my_emp_id_pk PRIMARY KEY(id);
  # 2. 向表dept2的id列中添加primary key约束(my_dept_id_pk)
  ALTER TABLE dept2 ADD CONSTRAINT my_dept_id_pk PRIMARY KEY(id);
  
  # 3. 向表emp2中添加列dept_id,并在其中定义foreign key约束，与之关联列时dept2表中的id列
  ALTER TABLE emp2 ADD COLUMN dept_id INT;
  ALTER TABLE emp2 ADD CONSTRAINT fk_emp_dept FOREIGN KEY(dept_id) REFERENCES dept2(id);
  
  /*
  		位置		支持的约束类型			是否可以起约束名
  列级约束：	列的后面	语法都是支持，但外键没有效果	不可以
  标记约束：	所有列的下面	默认和非空不支持，其他支持	可以(主键没有效果)
  */
  ```

### 标识列

```mysql
# 标识列
/*
又称为自增长列
含义：可以不用手动的插入值，系统提供默认的序列值

特点：
1. 标识列必须和主键搭配吗？不一定，但必须是key
2. 一个表最多可以有几个标识列？至多一个
3. 标识列的类型只能是数值型
4. 标识列可以通过SET auto_increment_increment 设置步长
   也可以通过 手动插入值。设置起始值

*/

# 一、创建表时设置标识列
DROP TABLE tab_identity;
CREATE TABLE tab_identity(
	id INT,
	NAME FLOAT,
	seat INT
);

TRUNCATE TABLE tab_identity;
INSERT INTO tab_identity VALUES(NULL,'john');

INSERT INTO tab_identity(NAME) VALUES('john');

SHOW VARIABLES LIKE '%auto_increment%';

# 设置增长幅度为3
SET auto_increment_increment=3;
# 设置起始值为5
INSERT INTO tab_identity VALUES(5,'john');

# 二、修改表时设置标识列
ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT ;

# 三，修改表时删除标识列
ALTER TABLE tab_identity MODIFY COLUMN id INT;
```

### 进阶12：TCL语言

> Transaction Control Language 事务控制语

- 事务的含义

  ![image-20201014183406005](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201014183406005.png)

- MySQL中的存储引擎

  ![image-20201014183851534](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201014183851534.png)

- 事务的ACID(acid)属性

  ![image-20201014184445080](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201014184445080.png)

- 数据库的隔离

  - ![image-20201015082431986](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201015082431986.png)

  - ![image-20201015082531650](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201015082531650.png)

  - 设置隔离级别

    ```mysql
    mysql> select @@tx_isolation;
    +-----------------+
    | @@tx_isolation  |
    +-----------------+
    | REPEATABLE-READ |
    +-----------------+
    1 row in set (0.00 sec)
    
    mysql> set session transaction isolation level read uncommitted;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql>  select @@tx_isolation;
    +------------------+
    | @@tx_isolation   |
    +------------------+
    | READ-UNCOMMITTED |
    +------------------+
    1 row in set (0.00 sec)
    ```

  - ![image-20201015084749161](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201015084749161.png)

  ````mysql
  # TCL语言
  /*
  Transaction Control Language 事务控制语
  
  事务：
  一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行
  
  案例：转账
  
  张三丰 1000
  郭襄   1000
  
  开启事务的语句：
  update 表 set 张三丰的余额=500 where name='张三丰'
  意外
  update 表 set 郭襄的余额=1500 where name='张三丰'
  
  事务的(ACID)特性：
  原子性：一个事务不可再分割，要么都执行，要么都不执行
  一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致的状态
  隔离性：一个事务的执行不会受到其他事务的干扰
  持久性：一个事务一旦提交，则会永久的改变数据库的数据
  
  事务的创建
  隐式事务：事务没有明显的开启和结束的标记
  比如insert、update、detele语句
  
  delete from 表 where id=1;
  
  显式事务：事务具有明显的开启和结束的标记
  前提：必须先设置自动提交功能为禁用
  set autocommit=0;
  
  步骤1：开启事务
  set autocommit=0;
  start transaction; # 可选
  步骤2：编写事务中的sql语句(select、insert、update、datele)
  语句1;
  语句2;
  ……
  步骤3：结束事务
  commit; # 提交事务
  rollback; # 回滚事务
  
  savepoint 节点名; # 设置保存点
  
  事务的隔离级别：
  			脏读	不可重复读    幻读	
  read uncommitted：	✓	✓	      ✓
  read committed：	✗	✓	      ✓
  repeatable read：	✗	✗	      ✓
  serializable：		✗	✗	      ✗
  mysql中默认，第三个隔离级别：repeatable read
  oracle中默认，第二个级别：read committed
  
  select @@tx_isolation;
  
  set session|global transaction isolation level read uncommitted;
  
  */
  # 查看存储引擎
  SHOW ENGINES;
  
  # 演示事务的使用步骤
  
  # 1. 开启事务
  SET autocommit=0;
  
  # 2. 编写一组事务的语句
  UPDATE account SET balance = 500 WHERE username='张无忌';
  UPDATE account SET balance = 1500 WHERE username='赵敏';
  
  # 回滚
  ROLLBACK;
  # 3. 结束事务
  COMMIT;
  
   
  # 演示savepoint的使用
  SET autocommit=0;
  START TRANSACTION;
  DELETE FROM account WHERE id=25;
  SAVEPOINT a; # 设置保存点
  DELETE FROM account WHERE id=29;
  ROLLBACK TO a; # 回滚到保存点
  
  SELECT * FROM account;
  ````

### 视图

- 含义：

  ![image-20201015091001526](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201015091001526.png)

  ```mysql
  # 视图
  /*
  含义：虚拟表，和普通表一样使用
  mysql5.1版本出现的新特性，是通过表动态生成的数据
  
  比如：舞蹈班和普通班的对比
  	创建语法的关键字	是否实际占用物理空间	使用
  
  视图	create view		只是保存了sql的逻辑	增删改查，一般不能增删改
  
  表	create table		保存了数据		增删改查
  
  */
  # 案例：查询姓张的学生名和专业名
  SELECT stuname,majorname
  FROM stuinfo a
  JOIN major m
  ON a.`majorId`=m.`id`
  WHERE a.`stuname`LIKE '张%';
  
  
  CREATE VIEW v1
  AS
  SELECT stuname,majorname
  FROM stuinfo a
  JOIN major m
  ON a.`majorId`=m.`id`;
  
  SELECT * FROM v1 WHERE stuname LIKE '张%';
  
  
  # 一、创建视图
  /*
  语法：
  create view 视图名
  as
  查询语句;
  
  */
  
  USE myemployees;
  
  # 1. 查询姓名中包含a字符的员工名、部门名和工种信息
  
  # ①创建
  CREATE VIEW myv1
  AS
  SELECT last_name,department_name,job_title
  FROM employees e
  JOIN departments d ON e.department_id = d.department_id
  JOIN jobs j ON j.job_id = e.job_id;
  
  # ②使用
  SELECT * FROM myv1 WHERE last_name LIKE '%a%';
  
  # 2. 查询各部门的平均工资级别
  # ①创建视图查看每个部门的平均工资
  CREATE VIEW myv2
  AS
  SELECT AVG(Salary) ag,department_id
  FROM employees
  GROUP BY department_id;
  
  SELECT * FROM myv2;
  
  # ②使用
  SELECT grade_level,department_id
  FROM job_grades j
  JOIN myv2 m
  WHERE m.`avg(Salary)` BETWEEN j.`lowest_sal` AND j.`highest_sal`;
  
  # 3. 查询平均工资最低的部门
  SELECT *
  FROM myv2
  ORDER BY ag
  LIMIT 1 ;
  
  # 4. 查询平均工资最低的部门名和工资
  
  SELECT m.`ag`,department_name
  FROM myv2 m
  INNER JOIN departments  d
  WHERE d.`department_id` = m.`department_id`
  ORDER BY ag 
  LIMIT 1;
  
  # 二、视图的修改
  
  # 方法一
  /*
  语法：
  create or replace view 视图名
  as
  查询语句;
  */
  
  SELECT * FROM myv3;
  CREATE OR REPLACE VIEW myv3
  AS
  SELECT AVG(salary),job_id
  FROM employees
  GROUP BY job_id;
  # 方式二
  /*
  语法：
  alter view 视图名
  as
  查询语句;
  
  */
  ALTER VIEW myv3
  AS
  SELECT * FROM employees;
  
  # 三、删除视图
  /*
  语法：
  drop view 视图名,视图名……;
  */
  DROP VIEW myv1,myv2,myv3;
  
  # 四、查看视图
  
  DESC myv3;
  SHOW CREATE VIEW myv3;
  
  # 五、视图的更新
  CREATE OR REPLACE VIEW myv1
  AS
  SELECT Last_name,email,Salary*(1+IFNULL(commission_pct,0)) "annual salary"
  FROM employees;
  
  CREATE OR REPLACE VIEW myv1
  AS
  SELECT Last_name,email,Salary
  FROM employees;
  
  SELECT * FROM myv1;
  
  # 1. 插入
  
  INSERT INTO myv1 VALUES('张飞','zf#qq.com',1000000);
  
  # 2. 修改
  UPDATE myv1 SET last_name = '张无忌' WHERE Last_name = '张飞';
  
  # 3. 删除
  DELETE FROM myv1 WHERE last_name='张无忌';
  
  # 具备以下特点的视图不允许更新
  
  /*
  ①包含以下关键字的sql语句：
   分组函数、distinct、group by、
   having、union或者union all
  ②常量视图
  ③select 中包含子查询
  ④join
  ⑥from 一个不能更新的视图
  ⑦where子句的子查询引用了from子句中的表
  */
  ```

  - 测试题

    ```mysql
    # 测试题
    
    # 1. 创建视图emp_v1,要求查询电话号码以'011'开头的员工姓名和工资、邮箱
    CREATE OR REPLACE VIEW emp_v1
    AS
    SELECT last_name,Salary,email
    FROM employees
    WHERE phone_number LIKE '011%';
    
    SELECT * FROM emp_v1;
    # 2. 创建视图emp_v2,要求查询部门的最高工资高于12000的部门信息
    CREATE OR REPLACE VIEW emp_v2
    AS
    SELECT d.*
    FROM departments AS d
    INNER JOIN employees AS e
    ON e.department_id = d.department_id
    GROUP BY d.department_id
    HAVING MAX(e.Salary) > 12000;
    
    SELECT * FROM emp_v2;
    ```

- 视图和事务的测试题

  ```mysql
  # 测试题
  
  # 1. 创建表book表，字段如下：
  /*
  bid 整型 要求主键
  bname 字符型 要求唯一，非空
  price 浮点型 要求默认10
  btypeId 类型编号，要求引用bookType表的id字段
  
  已知bookType表(不用创建)，字段如下：
  id
  name
  */
  
  CREATE TABLE book(
  	bid INT PRIMARY KEY,
  	bname VARCHAR(20) UNIQUE NOT NULL,
  	price FLOAT DEFAULT 10,
  	btypeId INT,
  	
  	CONSTRAINT fk_book_bookType FOREIGN KEY(btype) REFERENCES bookType(id)
  );
  
  # 2. 开启事务
  # 向表中插入一行数据，并结束
  SET autocommit=0;
  INSERT INTO book VALUES(1,"傻瓜的连成",250,5);
  COMMIT;
  
  # 3. 创建视图，实现查询价格大于100的书名和类型名
  
  CREATE VIEW v1
  AS
  SELECT bname,NAME
  FROM book AS b
  JOIN bookType AS bt
  ON b.btyptId = bt.id
  WHERE b.price > 100;
  
  # 4. 修改视图，实现查询价格在90-120之间的书名和价格
  CREATE OR REPLACE VIEW v1
  AS
  SELECT bname,NAME
  FROM book AS b
  JOIN bookType AS bt
  ON b.btyptId = bt.id
  WHERE b.price BETWEEN 90 AND 120;
  
  # WHERE b.price > 90 AND b.price < 120; 
  
  
  # 5. 删除刚才创建的视图
  DROP VIEW v1;
  ```

### 复习：DDL语言-常见的约束

- 复习：DDL语言-常见的约束

  - 常见的约束

    - not null：非空，该字段的值必填

    - unique：唯一，该字段的值不可重复

    - default：默认，该字段的值不用手动插入，有默认值

    - check：检查，MySQL不支持

    - primary key：主键，该字段不可重复并且非空 unique+not null

    - foreign key：外键，该该字段的值引用了另外的表的字段

    - 主键和唯一

      - 区别
        - 一个表至多有一个主键，但可以有多个唯一
        - 主键不支持为空，唯一可以为空
      - 相同点
        - 都具有唯一性
        - 都支持组合键，但不推荐

    - 外键

      - 用于限制两个表的关系，从表的字段引用了主表的某字段值

      - 外键和主表的被引用列要求类型一致，意义一样，名称无要求

      - 主表的被应用列表要求时一个key(一般就是主键)

      - 插入数据，先插入主表

        删除数据，先删除从表

      - 不先删除从表，直接删除主表的方法

        ```mysql
        SHOW INDEX FROM major;
        SHOW INDEX FROM stuinfo;
        # 传统的方式添加外键
        ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id);
        SELECT * FROM major;
        
        DELETE FROM stuinfo;
        SELECT * FROM stuinfo;
        INSERT INTO stuinfo 
        SELECT 1,'李强','男',NULL,NULL,1 UNION ALL
        SELECT 2,'李强','男',NULL,NULL,1 UNION ALL
        SELECT 3,'李强','男',NULL,NULL,2 UNION ALL
        SELECT 4,'李强','男',NULL,NULL,1 UNION ALL
        SELECT 5,'李强','男',NULL,NULL,2 UNION ALL
        SELECT 6,'李强','男',NULL,NULL,1;
        
        
        # 方式一：级联删除
        ALTER TABLE stuinfo DROP FOREIGN KEY fk_stu_major;
        ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;
        
        # 删除专业表的2号专业
        DELETE FROM major WHERE id=2;
        
        # 方式二：级联置空
        ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;
        
        # 删除专业表的2号专业
        DELETE FROM major WHERE id=2;
        ```

  - 创建表时添加约束

    ```mysql
    create table 表名(
    	字段名 字段类型 not null,# 非空
        字段名 字段类型 primary key,# 主键
        字段名 字段类型 unique,# 唯一
        字段名 字段类型 default 值,# 默认
        constraint 约束名 foreign key(字段名) references 主表(被引用列) # 外键
    );
    ```

    - 表级约束和列级约束

      |          | 支持类型       | 可以约束名         |
      | -------- | -------------- | ------------------ |
      | 列级约束 | 除了外键       | 不可以             |
      | 表级约束 | 除了非空和默认 | 可以，但对主键无效 |

      列级约束可以在一个字段上添加多个，中间用空格隔开，没有顺序要求

  - 修改表时添加或删除约束

    - 添加默认

      ```mysql
      alter table 表名 modify column 字段名 字段类型 default 值;
      ```

    - 删除默认

      ```mysql
      alter table 表名 modify column 字段名 字段类型;
      ```

    - 主键

      - 添加主键

        ```mysql
        alter table 表名 add 【 constraint 约束名 】 primary key(字段名);
        ```

      - 删除主键

        ```mysql
        alter table 表名 drop primary key;
        ```

    - 唯一

      - 添加唯一

        ```mysql
        alter table add 【 constraint 约束名 】 unique(字段名)
        ```

      - 删除唯一

        ```mysql
        alter table 表名 drop index 索引名;
        ```

    - 外键

      - 添加外键

        ```mysql
        alter table 表名 add 【 constraint 约束名 】 foreign key(字段名) references 主表(被引用段);
        ```

      - 删除外键

        ```mysql
        alter table 表名 drop foreign key 约束名;
        ```

  - 自增长列

    - 特点

      - 不用手动输入值，可以自动提供序列值，默认从1开始，步长为1

        ```mysql
        show variables like '%auto_increment%';
        
        Variable_name             Value   
        ------------------------  --------
        auto_increment_increment  1       
        auto_increment_offset     1       
        
        # auto_increment_increment 的 value 就是步长
        # auto_increment_offset 的 value 就是起始值
        ```

        如果要更改起始值：手动插入值

        如果需要更改步长：更改系统变量

        ```mysql
        set auto_increment_increment=值;
        ```

      - 一个表至多有一个自增长列

      - 自增长列只能支持数值型

      - 自增长列必须为一个key

    - 创建表时设置自增长列

      ```mysql
      create table 表(
      	字段名 字段类型 约束 auto_increment
      );
      ```

    - 修改表时设置自增长列

      ```mysql
      alter table 表 modify column 字段名 字段类型 约束 auto_increment;
      ```

    - 删除自增长列

      ```mysql
      alter table 表 modify column 字段名 字段类型 约束;
      ```

### 复习：TCL语言-事务

- 复习：TCL语言-事务

  - 含义

    事务：一条或多条sql语句组成一个执行单位，一组SQL语句要么执行要么不执行

  - 特点(ACID)

    - A 原子性：一个是事务是不可再分割的整体，要么都执行要么都不执行
    - C 一致性：一个事务可以使实际冲一个一致的状态切换到另一个一致的状态
    - I 隔离i性：一个事务不受其他事务的干扰，多个事务互相隔离的
    - D 持久性：一个事务一旦提交了，则永远的持久化到本地

  - 事务的使用步骤✦

    - 了解

      - 隐式(自动)事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete
      - 显式事务：具有明显的开启和结束

    - 使用显式事务

      - 开启事务

        ```mysql
        set autocommit=0;
        start transaction;# 可以省略
        ```

      - 编写一组sql语句

        - 注意：sql语句支持的是insert、update、delete

      - 设置回滚点

        ```mysql
        savepoint 回滚名;
        ```

      - 结束事务

        - 提交

          ```mysql
          commit;
          ```

        - 回滚：

          ```mysql
          rollback;
          ```

        - 回滚到指定点

          ```mysql
          rollback 回滚名
          ```

  - 并发事务

    - 事物的并发问题是如何发生的？

      多个事务，同时访问同一个数据库的相同数据时

    - 并发事务都有哪些？

      - 脏读：一个事务读取了其他事务
      - 不可重复读：一个事务多次读取，结果不一样
      - 幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务"插入"的数据

    - 如何解决并发事务

      通过设置隔离级别来解决并发问题

    - 隔离级别

      | 隔离级别(✓解决 ✗不能解决)  | 脏读 | 不可重复读 | 幻读 | 默认   | 支持            |
      | -------------------------- | ---- | ---------- | ---- | ------ | --------------- |
      | read uncommitted：读未提交 | ✗    | ✗          | ✗    |        | MySQL           |
      | read committed：读已提交   | ✓    | ✗          | ✗    | Oracle | MySQL<br>Oracle |
      | repeatable read：可重复读  | ✓    | ✓          | ✗    | MySQL  | MySQL           |
      | serializable：串口化       | ✓    | ✓          | ✓    |        | MySQL<br>Oracle |

### 复习：视图

- 复习：视图

  - 含义

    mysql5.1版本出现的新特性，本身是一个虚拟表，他的数据来自于表，通过执行时动态生成。

    - 好处
      - 简化sql语句
      - 提高了sql的重用性
      - 保护基表的数据，提高了安全性

  - 视图的创建

    - 语法：

      ```mysql
      create view 视图名
      as
      查询语句;
      ```

  - 视图的修改

    - 方式一

      ```mysql
      create or replace view 视图名
      as
      查询语句;
      ```

    - 方式二

      ```mysql
      alter view 视图名
      as
      查询语句;
      ```

  - 视图的删除

    - 语法

      ```mysql
      drop view 视图1,视图2……;
      ```

  - 视图的查看

    - 语法

      ```mysql
      desc 视图名;
      show create view 视图名;
      ```

  - 视图的使用

    - 插入

      ```mysql
      insert
      ```

    - 修改

      ```mysql
    update
      ```

    - 删除

      ```mysql
    delete
      ```

    - 查看

      ```mysql
    select
      ```
      
    - 注意：视图一般用于查取，而不是更新的，所有具备以下特点的视图都不被允许更新
    
      - ①包含以下关键字的sql语句：
         分组函数、distinct、group by、
         having、union或者union all
      - ②常量视图
      - ③select 中包含子查询
      - ④join
      - ⑤from 一个不能更新的视图
      - ⑥where子句的子查询引用了from子句中的表

  - 视图和表的对比

    |      | 关键字 | 是否占用物理空间        | 使用         |
    | ---- | ------ | ----------------------- | ------------ |
    | 视图 | view   | 占用较小，只保存sql逻辑 | 一般用于查询 |
    | 表   | table  | 保存实际的数据          | 增删改查     |



### 变量

```mysql
# 变量
/*
系统变量：
	全局变量
	会话变量

自定义变量：
	用户变量
	局部变量
*/
# 一、系统变量
/*
说明：变量由系统提供，不是用户定义，属于服务器层面

注意：
如果是全局级别，则需要加global
如果是会话级别，则需要加session
如果不写，则默认session

使用语法：
1. 查看所有的系统变量
show variables; # 查看会话变量
show global variables; # 查看全局变量
show session variables; # 查看会话变量
show global|【session】 variables;

2. 查看满足提交的部分系统变量

show global|【session】 variables like '%char%';

3. 查看指定的某个系统变量的值

select @@系统变量名; # 查看指定的会话系统变量
select @@global.系统变量名; # 查看指定的全局系统变量
select @@session.系统变量名; # 查看指定的会话系统变量

select @@global|【session】.系统变量;

4. 为某个系统变量赋值
方式一：
set 系统变量名=值; # 为系统变量赋值
set global.系统变量名 = 值; # 为全局系统变量赋值
set session.系统变量名 = 值; # 为会话系统变量赋值

set global|【session】.系统变量名 = 值;

方式二：
set @@系统变量名=值; # 为系统变量赋值
set @@global.系统变量名 = 值; # 为全局系统变量赋值
set @@session.系统变量名 = 值; # 为会话系统变量赋值

set @@global|【session】.系统变量名 = 值;
*/


# 1. 全局变量
/*
作用域：服务器每次启动将为所有的全局变量赋初始值，
	针对于所有的会话(连接)有效，但不能跨重启。
*/
# ①查看所有的全局变量
SHOW GLOBAL VARIABLES;

# ②查看部分的全局变量

SHOW GLOBAL VARIABLES LIKE '%char%';


# ③查看指定的全局变量的值
SELECT @@global.autocommit;
SELECT @@global.tx_isolation;

# ④为某个指定的全居变量赋值
SET @@global.autocommit=1;

# 2. 会话变量
/*
作用域：仅仅针对当前会话(连接)有效

*/
# ①查看所有的会话变量
SHOW VARIABLES;
SHOW SESSION VARIABLES;

# ②查看部分的会话变量

SHOW VARIABLES LIKE '%char%';

# ③查看指定的会话变量的值
SELECT @@session.autocommit;
SELECT @@tx_isolation;

# ④为某个指定的会话变量赋值
# 方法一：
SET @@session.autocommit=1;
# 方法二：
SET SESSION tx_isolation = 'read-uncommitted';


# 二、自定义变量
/*
说明：变量是用户自定义的，不是由系统的
使用步骤：
声明
赋值
使用(查看、比较、运算)
*/

# 1. 用户变量
/*
作用域：针对于当前会话(连接)有效，同于会话变量的作用域
应用在任何地方，也就是begin end里面或begin end外面
*/

赋值的操作符：=或:=
# ①声明并初始化
SET @用户变量名=值;
SET @用户变量名:=值;
SELECT @用户变量名:=值;

#②赋值(更新用户变量的值)
方式一：通过 SET 或 SELECT
	SET @用户变量名=值;
	SET @用户变量名:=值;
	SELECT @用户变量名:=值;
方法二：通过 SELECT INTO
	SELECT 字段 INTO 用户变量名
	FROM 表;
	
# ③查看
SELECT @用户变量名;



# 案例：
# ①声明并初始化
SET @name='john';
SET @name=100;
SET @count=1;

#②赋值(更新用户变量的值)
SELECT COUNT(*) INTO @count
FROM employees;

# ③使用(查看用户变量的值)
SELECT @count;


# 2. 局部变量
/*
作用域：仅仅在定义它的begin end中有效
应用在 begin end中的第一句话
*/
# ①声明
DECLARE 变量名 类型;
DECLARE 变量名 类型 DEFAULT 值;

# ②赋值
方式一：通过 SET 或 SELECT
	SET 局部变量名=值;
	SET 局部变量名:=值;
	SELECT @局部变量名:=值;
方法二：通过 SELECT INTO
	SELECT 字段 INTO 局部变量名
	FROM 表;

# ③使用(查看用户变量的值)
SELECT 局部变量名;

# 对比用户变量和局部变量：

		   作用域		    定义和使用的位置			         语法
用户变量	当前会话	    会话中的任何地方			          必须加上 @ 符号，不用限定类型
局部变量	BEGIN END 中	  只能在 BEGIN END 中，且为第一句话      一般不用加 @ 符号，需要吸纳等类型

# 案例：声明两个变量并赋初始值，求和，并打印

# 用户变量
SET @a = 5;
SET @b = 6;
SELECT @a+@b;

# 局部变量
DECLARE a INT DEFAULT 1;
DECLARE b INT DEFAULT 2;
DECLARE sum1 INT;
SET sum1 = a+b;
SELECT sum1;
```

### 存储过程和函数

- 存储过程和函数

  ```mysql
  # 存储过程和函数
  /*
  存储过程和函数，类似于jsva中的方法
  好处：
  1. 提高代码的重用性
  2. 简化操作
  */
  ```

  - 存储过程

    ```mysql
    # 一、存储过程
    /*
    含义：一组预先编译好的SQL语句的集合，理解成批处理语句
    
    1. 提高代码的重用性
    2. 简化操作
    3. 减少了编译次数并且减少了数据库服务器的连接次数，提高了效率
    */
    
    # 1. 创建语法
    create procedure 存储过程名(参数列表)
    begin
    	存储过程体(一组合法的SQL语句)
    end
    注意：
    1. 参数列表包含三部分
       参数模式、参数名、参数类型
    举例：
    in stuname varchar(20)
    
    参考模式：
    in: 该参数可以作为输入，也就是该参数需要调用方法传入值
    out: 该参数可以作为输出，页就是该参数可以作为返回值
    inout: 该参数可以作为输入又可以作为输出，也就是该参数接需要传入值，又可以返回值
    
    2. 如果存储过程题仅仅只有一句话， begin end 可以省略
       存储过程体中每条sql语句的结尾要求必须加分号.
       存储过程的结尾可以使用 delimiter 重新设置
    语法：
    delimiter 结束标记
    
    delimiter s
    
    # 2. 调用语法
    
    call 存储过程名(实参列表);
    
    # 2.1空参列表
    
    # 案例：插入到admin表中五条记录
    
    select * from admin;
    
    delimiter $ # 设置结尾符号为$
    create procedure myp1()
    begin
    	insert into admin(username,`password`) values
    	('john1','0000'),
    	('lily','0000'),
    	('rose','0000'),
    	('jack','0000'),
    	('tom','0000');
    
    end $
    
    # 调用
    call myp1()$
    
    select * from admin$
    
    # 2.2 创建存储过程实现 根据女神名，查询对应的男神信息
    
    create procedure myp2(in beautyName varchar(20))
    begin
    	select bo.*
    	from boys bo
    	right join beauty b on bo.id = b.boyfriend_id
    	where b.name = beautyName;
    end $
    
    # 调用
    call myp2('柳岩')$
    
    # 案例2：创建存储过程实现，用户是否登录成功
    
    create procedure myp3(in username varchar(20),in password varchar(20))
    begin
    	declare result varchar(20) default '';# 声明并初始化
    	select COUNT(*) into result # 赋值
    	from admin
    	where admin.`username` = username
    	and admin.`password` = password;
    	
    	select result;# 使用
    end $
    
    
    create procedure myp4(in username varchar(20),in password varchar(20))
    begin
    	declare result int default 0;# 声明并初始化
    	select COUNT(*) into result # 赋值
    	from admin
    	where admin.`username` = username
    	and admin.`password` = password;
    	
    	select IF(result>0,'成功','失败') '判断';# 使用
    end $
    
    # 调用
    call myp3('john','8888')$
    
    call myp4('john','8888')$
    
    # 2.3 创建带out模式的存储过程
    
    # 案例1：根据女神名，返回对应的男生名
    create procedure myp5(in beautyName varchar(20),out boyName varchar(20))
    begin
    	select bo.boyName into boyName
    	from boys bo
    	inner join beauty b on bo.id = b.boyfriend_id
    	where b.name = beautyName;
    	
    end $
    
    # 调用
    call myp5('小昭',@bname)$
    select @bname$
    
    # 案例2：根据女神名，分会对应的男生名和魅力值
    create procedure myp6(in beautyName varchar(20),out boyName varchar(20),out userCP varchar(20))
    begin
    	select bo.boyName,bo.userCP into boyName, userCP
    	from boys bo
    	inner join beauty b on bo.id = b.boyfriend_id
    	where b.name = beautyName;
    	
    end $
    
    # 调用
    call myp6('小昭',@bname,@userCP)$
    select @bname,@userCP$
    
    
    # 4. 创建带inout模式参数的存储过程
    # 案例1：传入a和b两个值，最终a和b都翻倍并返回
    
    create procedure myp7(inout a int,inout b int)
    begin
    	set a = a*2;
    	set b = b*2;
    end $
    
    
    # 调用
    
    set @a = 10$
    set @b = 8$
    call myp7(@a,@b)$
    select @a,@b$
    
    # 二、删除存储过程
    /*
    语法：drop procedure 存储过程名
    */
    drop procedure myp1$
    
    # 三、查看存储过程的信息
    show create procedure myp2;
    ```

    - 测试题

      ```mysql
      # 测试题
      # 记得delimiter $
      # 一、创建存储过程或函数实现传入用户名和密码，插入到admin表中
      create procedure myp8(in username varchar(20),in password varchar(20))
      begin
      	insert into admin(username,password) values(username,password);
      end $
      call myp8('lsp','123456')$
      # 二、创建存储过程或函数实现传入女神编号，返回女神名称和女神电话
      create procedure myp9(in sid int,out sname varchar(20),out sphone varchar(20))
      begin
      	select name,phone into sname,sphone
      	from beauty
      	where id = sid;
      end $
      call myp9(9,@name,@nu)$
      select @name,@nu$
      # 三、创建存储过程或函数实现传入两个女神生日，返回大小
      create procedure myp10(in date1 datetime,in date2 datetime,out big varchar(20))
      begin
      	select IF(date1>date2,date1,date2) into big;
      end$
      call myp10('1999-9-1','1999-8-1',@big)$
      select @big$
      
      # 四、创建存储过程或函数实现传入一个日期，格式化xx年xx月xx日并返回
      create procedure myp11(in Dtime datetime,out str varchar(20))
      begin
      	select DATE_FORMAT(Dtime,'%y年%m月%d日') into str;
      end $
      
      call myp11('1999-8-9',@time)$
      select @time$
      
      # 五、创建存储过程或函数传入女生神名称，返回：女神 and 男生 格式的字符串
      # 如：传入 小昭
      # 返回 小昭 and 张无忌
      
      create procedure myp12(in vname varchar(20),out str varchar(20))
      begin
      	select CONCAT(vname,' and ',IFNULL(boyName,'null')) into str
      	from beauty b
      	join boys bo
      	on b.boyfriend_id = bo.id
      	where b.name = vname;
      end $
      
      call myp12('小昭',@str)$
      select @str$
      
      # 六、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录
      
      create procedure myp13(in size int,in off int)
      begin
      	select *
      	from beauty
      	limit off,size;
      end $
      
      call myp13(5,5)$
      ```

  - 函数

    ```mysql
    # 函数
    /*
    含义：一组预先编译好的sql语句的集合，理解成批处理语句
    1. 提高代码的重用性
    2. 简化操作
    3. 减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率
    
    区别：
    存储过程：可以有0个返回，也可以有多个返回，适合做批量出入、批量更新
    函数：有且仅有一个返回，适合做处理数据后返回一个结果
    
    */
    
    # 一、创建语法
    
    create function 函数名(参数列表) returns 返回类型
    begin
    	函数体
    end $
    /*
    注意：
    参数列表 包含两部分
    参数名 参数类型
    
    函数体：肯定会有return语句，如果没有会报错
    如果return语句没有放在函数体的最后也不报错，但不建议
    
    return 值;
    3. 函数体中仅有一句话，则可以省略begin end
    4. 使用 delimiter 语句作为设置结束标记
    
    delimiter $;
    */
    
    # 二、调用语法
    select 函数名(参数列表)
    
    # 案例演示
    # 1. 无参有返回
    # 案例：返回公司的员工个数
    create function myf1() returns int
    begin
    	declare c int default 0; # 定义一个变量
    	select COUNT(*) into c #赋值
    	from employees;
    	return c;
    end $
    
    select myf1$
    
    # 2.有参有返回
    # 案例1：根据员工名，返回他的工资
    create function myf2(vname varchar(25)) returns double
    begin
    	declare s double default 0;
    	select salary into s
    	from `employees` e
    	where  e.`last_name` = vname
    	limit 1;
    	return s;
    end $
    
    select myf2('K_ing')$
    
    # 案例2：根据部门名，返回部门的平均工资
    create function myf3(dname varchar(20)) returns double
    begin
    	declare s double default 0;
    	select AVG(Salary) into s
    	from employees e
    	join departments d on e.department_id = d.department_id
    	where d.department_name = dname;
    	return s;
    end $
    
    select myf3('IT')$
    
    # 三、查看函数
    show create function myf3$
    
    # 四、删除函数
    drop function myf3;
    ```

    - 测试题

      ```mysql
      # 创建函数，实现传入两个float，返回二者之和
      create function myf4(a float,b float) returns float
      begin
      	declare f float default 0;
      	set f = a+b;
      	return f;
      end $
      
      select myf4(4.1,4.5)$
      ```

### 流程控制结构

- 流程控制结构

  ```mysql
  # 流程控制结构
  /*
  顺序结构：程序从上往下一次执行
  分支结构：程序重两条或多条路径中选择一条去执行
  循环结构：程序在满足一定条件的基础上，重复执行一段代码
  */
  ```

  - 分支结构

    - if函数

      ```mysql
      # 一、分支结构
      # 1. if函数
      /*
      功能：实现简单的双分支
      语法：
      if(表达式1,表达式2,表达式3)
      执行顺序：
      如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值
      应用：任何地方
      */
      ```

    - case结构

      ![image-20201015175728335](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201015175728335.png)

      ```mysql
      # 2. case结构
      /*
      情况1：类似于java中的switch语句，一般用于实现等值判断
      语法：
      	case 变量|表达式|字段
      	when 要判断的值 then 返回的值或语句;
      	when 要判断的值 then 返回的值或语句;
      	when 要判断的值 then 返回的值或语句;
      	……
      	else 要返回的值或语句;
      	end case;
      情况2：类似于java中的多种if语句，一般用于实现区间
      语法：
      	case
      	when 要判断的条件 then 返回的值或语句;
      	when 要判断的条件 then 返回的值或语句;
      	when 要判断的条件 then 返回的值或语句;
      	……
      	else 要返回的值或语句;
      	end case;
      特点：
      ①
        可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end中或者begin end 的外面
        可以作为独立的语句去使用，只能放在begin end中
      ②
        如果when中的值满足或条件成立，则执行对应then后面的语句，并且结束case
        如果不满足，则执行else中的语句或则值
      ③else 可以省略，如果else省略了，并且所有when条件都不满足，则返回null
      
      */
      
      # 案例
      # 创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：
      # 90-100，显示A
      # 80-90，显示B
      # 60-80，显示C
      # 显示D
      create procedure myp1(in a int)
      begin
      	case
      	when a >= 90 then select 'A';
      	when a >= 80 then select 'B';
      	when a >= 60 then select 'C';
      	else select 'D';
      	end case;
      end $
      
      call myp1(50)$
      ```

    - if结构

      ```mysql
      # if结构
      /*
      功能：实现多重分支
      if 条件1 then 语句1;
      elseif 条件2 then 语句2;
      ……
      【else 语句n;】
      end if;
      
      应用在begin end中
      */
      
      # 案例：创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：
      # 90-100，返回A
      # 80-90，返回B
      # 60-80，返回C
      # 返回D
      
      
      create function myf5(s int) returns char
      begin
      	if s>=90 and s<=100 then return 'A';
      	elseif s>=90 and s<=100 then return 'B';
      	elseif s>=90 and s<=100 then return 'C';
      	else return 'D';
      	end if;
      end $
      
      call myf5(86)$
      ```

  - 循环结构

    ```mysql
    # 二、循环结构
    /*
    分类：
    while、loop、repeat
    
    循环控制：
    iterate 类似于 continue，继续，结束本次循环，继续下一次
    leave 类似于 break，跳出，结束当前的所在的循环
    
    */
    # 1.while
    /*
    语法：
    【标签：】while 循环条件 do
    	循环体
    end while【 标签】;
    
    联想：
    while(循环条件):
    	循环体;
    */
    
    # 2.loop
    /*
    语法：
    【标签：】loop
    	循环体
    end loop【 标签】;
    可以用来模拟简单的死循环
    */
    
    # 3.repeat
    /*
    语法：
    【标签：】repeat
    	循环体
    until 结束循环的条件
    end repeat【 标签】;
    */
    
    # 没有添加循环控制语句
    # 案例：批量插入，根据次数插入到admin表多条记录
    
    
    create procedure wile(in j int)
    begin
    	declare i int default 1;
    	while i<= j do
    		insert into admin(username,password) value(CONCAT('rose',i),'666');
    		set i=i+1;
    	end while;
    end $
    
    call wile(100)$
    
    
    # 添加leave语句
    # 案例：批量插入，根据次数插入到admin表多条记录,如果次数大于20则停止
    
    create procedure wile1(in j int)
    begin
    	declare i int default 1;
    	a:while i<= j do
    		insert into admin(username,password) value(CONCAT('rose',i),'666');
    		if i>=20 then leave a;
    		end if;
    		set i=i+1;
    	end while a;
    end $
    
    call wile1(100)$
    
    
    # 添加iterate语句
    # 案例：批量插入，根据次数插入到admin表多条记录,只插入偶数列
    
    create procedure wile2(in j int)
    begin
    	declare i int default 0;
    	set i=i+1;
    	a:while i<= j do
    		if MOD(i,2)!=0 then iterate a;
    		end if;
    		insert into admin(username,password) value(CONCAT('rose',i),'666');
    	end while a;
    end $
    
    call wile2(100)$
    ```

    ![image-20201015183703252](C:\Users\Alex\AppData\Roaming\Typora\typora-user-images\image-20201015183703252.png)

- 经典题目

  ```mysql
  # 经典题目
  /*
  一、已知表stringcontent
  其中字段：
  id 自增长
  content varchar(20)
  
  向该表插入指定个数的“随机字符串”
  */
  create table stingcontent(
  	id int primary key auto_increment,
  	content varchar(20)
  );
  
  create procedure text_randint_insert(in j int)
  begin
  	declare i int default 1;
  	declare str varchar(20) default 'abcdefghigklmnopqrstuvwxyz';
  	declare indx int default 1;# 代表起始索引
  	declare len int default 1;# 代表起始长度
  	while i <= j do
  		
  		set len = FLOOR(RAND()*(20-indx+1)+1); # 产生一个随机整数，代表截取长度 1~(26-indx+1)
  		set indx = FLOOR(RAND()*26+1); # 产生一个随机整数，代表起始索引1~26
  		insert into sringcontent(coutent) values(SUBSTR(str,indx,len));
  		set i = i+1;
  	end while;
  end $
  ```

### 复习：变量

- 复习：变量

  - 分类

    - 系统变量

      说明：变量由系统提供的，不用自定义

      语法：

      ①查看系统变量

      ```mysql
      show 【 global|session】 variable like '';# 如果没有显性声明global，则默认是session
      ```

      ②查看指定的系统变量的值

      ```mysql
      select @@【 global|session】.变量名;# 如果没有声明global，则默认session
      ```

      ③为系统变量赋值

      ```mysql
      # 方式一
      set 【 global|session】 变量名=值;# 如果没有声明global，则默认session
      # 方式二
      set @@global.变量名=值；
      set @@变量名=值;
      ```

      - 全局变量

        服务层面上的，必须拥有super权限才能为系统赋值，作用域为整个服务器，也就是针对所有连接(会话)有效

      - 会话变量

        服务器为每个连接的客户端都提供了系统变量，作用域为当前的连接(会话)

    - 自定义变量

      说明：自己定义的变量

      - 用户变量

        作用域：针对于当前连接(会话)生效

        位置：begin end里面或外面

        使用：

        ①声明并赋值

        ```mysql
        set @变量名=值;# 这个是最好用的，自己测试时用
        set @变量名:=值;
        select @变量名:=值;# 个人认为这是最好的，程序调用数据库时用
        ```

        ②更新值

        ```mysql
        # 方式一
        set @变量名=值;
        set @变量名:=值;
        select @变量名:=值;
        # 方式二
        select xx into @变量名 from 表;
        ```

        ③使用

        ```mysql
        select @变量名;
        ```

      - 局部变量

        作用域：仅仅在定义它的begin end 中使用

        位置：只要放在begin end中，而且只能放在第一句

        ```mysql
        create procedure prol()
        begin
        	declare i int default 1;
        end $
        ```

        使用：
        
        ①声明
        
        ```mysql
        declare 变量名 类型 【 default 值】;
        ```
        
        ②赋值或更新
        
        ```mysql
        # 方式一
        set 变量名=值;
        set 变量名:=值;
        select 变量名:=值;
        # 方式二
        select xx into 量名 from 表;
        ```
        
        ③使用
        
        ```mysql
        select 变量名:
        ```
        

### 复习：存储过程和函数

- 复习：存储过程和函数

- 说明：都类似于java中的方法，将一组完成特定功能的逻辑语句包装起来，对外暴露名字

  - 好处

  - 提高重用性

    - sql语句见到那

    - 减少了和数据库服务器连接的次数，提高了效率
    
  - 存储过程

    - 创建★

      ```mysql
      create procedure 存储过程名(参数模式 参数名 参数类型)
      begin
      	存储过程体
      end $
      ```

      注意：

      ①参数模式：in、out、inout，其中in可以省略
      
      ②存储过程体的每一条sql语句都需要用分号结尾
      
     - 调用
    
       ```mysql
       call 存储过程名(实参);
       # 调用in模式的存储过程
       call 存储过程('值');
       # 调用out模式的存储过程
       set @变量;
       call 存储过程(@变量);
       select @变量;
       # 调用inout模式的存储过程
       set @变量=值;
       call 存储过程(@变量);
       select @变量;
       ```
    
     - 查看
    
       ```mysql
       show create procedure 存储过程名;
       ```
    
     - 删除
    
       ```mysql
       drop procedure 存储过程名;
       ```
    
  - 函数

    - 创建★

      ```mysql
      create function 函数名(参数名 参数类型) returns 返回类型
      begin
      	函数体
      end $
      ```

      注意：

      函数体中肯定需要有return语句
      
     - 调用
    
       ```mysql
       call 函数名(实参列表);
       ```
       
     - 查看
    
       ```mysql
       show create function 函数名;
       ```
    
     - 删除
    
       ```mysql
       drop function 函数名;
       ```

### 复习：流程控制结构

- 复习：流程控制结构

  - 说明：

    - 顺序结构：程序从上往下依次执行
    - 分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行
    - 循环结构：程序满足一定条件下，重复执行一组语句

  - 分支结构

    - if语句

      功能：实现简单双分支

      语法：

      ```mysql
      if(条件,值1,值2);
      ```

      位置：

      可以作为表达式放在任何位置

    - case机构

      功能：实现多分支

      语法：

      ```mysql
      # 语法一
      case 表达式或字段
      when 值1 then 语句1;
      when 值2 then 语句2;
      when 值3 then 语句3;
      ……
      else 语句n;
      end 【 case】;
      
      # 语法二
      case
      when 条件1 then 语句1;
      when 条件2 then 语句2;
      when 条件3 then 语句3;
      ……
      else 语句n;
      end 【 case】;
      ```

      位置：

      可以放在任何位置

      如果放在begin end外面，作为表达式结合着其他语句使用

      如果放在begin end里面，一般作为独立的语句使用

    - if结构

      功能：实现多分支

      语法：

      ```mysql
      if 条件1 then 语句1;
      elseif 条件2 then 语句2;
      elseif 条件3 then 语句3;
      ……
      else 语句n;
      end if;
      ```

      位置：

      只能放在begin end中

  - 循环结构

    - 位置：只能放在begin end中
    - 特点：都能实现循环结构

    - 对比：

      ①这三种循环结构都可以省略，但如果循环中添加了循环控制语句(leave或iterate)，则必须添加名称

      ②loop：一般用于实现简单的死循环

      ​	wile：先判断后执行

      ​	repeat：先执行后判断，无条件执行一次

    - while

      语法：

      ```mysql
      【名称:】 while 循环条件 do
      	循环体
      end while 【名称】;
      ```

    - loop

      语法：

      ```mysql
      【名称:】 loop
      	循环体
      end loop 【名称】;
      ```

    - repeat

      语法：

      ```mysql
      【名称:】 repeat
      	循环体
      until 结束条件
      end repeat 【名称】;
      ```

    - 循环控制语句

      - leave：类似于break，用于跳出所在的循环
      - iterate：类似于continue，用于结束本次循环，继续下一次
