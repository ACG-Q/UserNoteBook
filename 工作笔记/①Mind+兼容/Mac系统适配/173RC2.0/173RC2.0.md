---
title: 173RC2.0
date created: 星期二, 二月 21日 2023, 10:05:28 上午
date modified: 星期三, 二月 22日 2023, 9:46:01 上午
---

# 173RC2.0

## 兼容准备

### 嵌入式

#### 主板 Esp 8266

[GitHub - esp8266/Arduino: ESP8266 core for Arduino](https://github.com/esp8266/Arduino/)

>[!done]- 步骤① 保存一份 `package_esp8266com_index.template.json`
> [Arduino/package_esp8266com_index.template.json at 78444a5037eeefd0a442b1abff4dcfd1cf74c310 · esp8266/Arduino (github.com)](https://github.com/esp8266/Arduino/blob/78444a5037eeefd0a442b1abff4dcfd1cf74c310/package/package_esp8266com_index.template.json)
> ![[package_esp8266com_index.template.json]]

> [!info]- 步骤②python `get.py`
>
> ~~~python
> #!/usr/bin/env python3
> # This script will download and extract required tools into the current directory.
> # Tools list is obtained from package/package_esp8266com_index.template.json file.
> # Written by Ivan Grokhotkov, 2015.
> #
> from __future__ import print_function
> import os
> import shutil
> import errno
> import os.path
> import hashlib
> import json
> import platform
> import sys
> import tarfile
> import zipfile
> import re
> 
> verbose = True
> 
> if sys.version_info[0] == 3:
>     from urllib.request import urlretrieve
> else:
>     # Not Python 3 - today, it is most likely to be Python 2
>     from urllib import urlretrieve
> 
> dist_dir = 'dist/'
> 
> def sha256sum(filename, blocksize=65536):
>     hash = hashlib.sha256()
>     with open(filename, "rb") as f:
>         for block in iter(lambda: f.read(blocksize), b""):
>             hash.update(block)
>     return hash.hexdigest()
> 
> def mkdir_p(path):
>     try:
>         os.makedirs(path)
>     except OSError as exc:
>         if exc.errno != errno.EEXIST or not os.path.isdir(path):
>             raise
> 
> def report_progress(count, blockSize, totalSize):
>     global verbose
>     if verbose:
>         percent = int(count*blockSize*100/totalSize)
>         percent = min(100, percent)
>         sys.stdout.write("\r%d%%" % percent)
>         sys.stdout.flush()
> 
> def unpack(filename, destination):
>     dirname = ''
>     print('Extracting {0}'.format(filename))
>     if filename.endswith('tar.gz'):
>         tfile = tarfile.open(filename, 'r:gz')
>         tfile.extractall(destination)
>         dirname= tfile.getnames()[0]
>     elif filename.endswith('zip'):
>         zfile = zipfile.ZipFile(filename)
>         zfile.extractall(destination)
>         dirname = zfile.namelist()[0]
>     else:
>         raise NotImplementedError('Unsupported archive type')
> 
>     # a little trick to rename tool directories so they don't contain version number
>     rename_to = re.match(r'^([a-zA-Z_][^\-]*\-*)+', dirname).group(0).strip('-')
>     if rename_to != dirname:
>         sourceDirName = os.path.join(destination, dirname)
>         targetDirName = os.path.join(destination, rename_to)
>         print('Renaming {0} to {1}'.format(sourceDirName, targetDirName))
>         if os.path.isdir(targetDirName):
>             shutil.rmtree(targetDirName)
>         shutil.move(sourceDirName, targetDirName)
> 
> def get_tool(tool, unpackPath):
>     archive_name = tool['archiveFileName']
>     local_path = dist_dir + archive_name
>     url = tool['url']
>     real_hash = tool['checksum'].split(':')[1]
>     if not os.path.isfile(local_path):
>         print('Downloading ' + archive_name);
>         urlretrieve(url, local_path, report_progress)
>         sys.stdout.write("\rDone\n")
>         sys.stdout.flush()
>     else:
>         print('Tool {0} already downloaded'.format(archive_name))
>     local_hash = sha256sum(local_path)
>     if local_hash != real_hash:
>         print('Hash mismatch for {0}, delete the file and try again'.format(local_path))
>         raise RuntimeError()
>     if unpackPath:
>         unpack(local_path, unpackPath)
>     else:
>         unpack(local_path, '.')
> 
> def load_tools_list(filename, platform):
>     tools_info = json.load(open(filename))['packages'][0]['tools']
>     tools_to_download = []
>     for t in tools_info:
>         tool_platform = [p for p in t['systems'] if p['host'] == platform]
>         if len(tool_platform) == 0:
>             continue
>         tools_to_download.append(tool_platform[0])
>     return tools_to_download
> 
> def identify_platform():
>     arduino_platform_names = {'Darwin'  : {32 : 'i386-apple-darwin',   64 : 'x86_64-apple-darwin'},
>                               'Linux'   : {32 : 'i686-pc-linux-gnu',   64 : 'x86_64-pc-linux-gnu'},
>                               'LinuxARM': {32 : 'arm-linux-gnueabihf', 64 : 'aarch64-linux-gnu'},
>                               'Windows' : {32 : 'i686-mingw32',        64 : 'x86_64-mingw32'}}
>     bits = 32
>     if sys.maxsize > 2**32:
>         bits = 64
>     sys_name = platform.system()
>     if 'Linux' in sys_name and (platform.platform().find('arm') > 0 or platform.platform().find('aarch64') > 0):
>         sys_name = 'LinuxARM'
>     if 'CYGWIN_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MSYS_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MINGW' in sys_name:
>         sys_name = 'Windows'
>     return arduino_platform_names[sys_name][bits]
> 
> def main(fileJSON, name):
>     global verbose
>     # Support optional "-q" quiet mode simply
>     if len(sys.argv) == 2:
>         if sys.argv[1] == "-q":
>             verbose = False
>     # Remove a symlink generated in 2.6.3 which causes later issues since the tarball can't properly overwrite it
>     if (os.path.exists('python3/python3')):
>         os.unlink('python3/python3')
>     print('Platform: {0}'.format(identify_platform()))
>     tools_to_download = load_tools_list(fileJSON, identify_platform())
>     mkdir_p(dist_dir)
>     mkdir_p(name)
>     for tool in tools_to_download:
>         get_tool(tool, name)
> 
> if __name__ == '__main__':
>     main('package_esp8266com_index.template.json', "eps8266")
> ~~~

![[Pasted image 20230221101412.png]]
![[Pasted image 20230221101446.png]]

#### 主板 Pico

>[!done]- 步骤① 保存一份 `package_pico_index.template.json`
> [arduino-pico/package\_pico\_index.template.json at master · earlephilhower/arduino-pico · GitHub](https://github.com/earlephilhower/arduino-pico/blob/master/package/package_pico_index.template.json)
> ![[package_pico_index.template.json]]

> [!info]- 步骤②python `get.py`
>
> ~~~python
> #!/usr/bin/env python3
> # This script will download and extract required tools into the current directory.
> # Tools list is obtained from package/package_esp8266com_index.template.json file.
> # Written by Ivan Grokhotkov, 2015.
> #
> from __future__ import print_function
> import os
> import shutil
> import errno
> import os.path
> import hashlib
> import json
> import platform
> import sys
> import tarfile
> import zipfile
> import re
> 
> verbose = True
> 
> if sys.version_info[0] == 3:
>     from urllib.request import urlretrieve
> else:
>     # Not Python 3 - today, it is most likely to be Python 2
>     from urllib import urlretrieve
> 
> dist_dir = 'dist/'
> 
> def sha256sum(filename, blocksize=65536):
>     hash = hashlib.sha256()
>     with open(filename, "rb") as f:
>         for block in iter(lambda: f.read(blocksize), b""):
>             hash.update(block)
>     return hash.hexdigest()
> 
> def mkdir_p(path):
>     try:
>         os.makedirs(path)
>     except OSError as exc:
>         if exc.errno != errno.EEXIST or not os.path.isdir(path):
>             raise
> 
> def report_progress(count, blockSize, totalSize):
>     global verbose
>     if verbose:
>         percent = int(count*blockSize*100/totalSize)
>         percent = min(100, percent)
>         sys.stdout.write("\r%d%%" % percent)
>         sys.stdout.flush()
> 
> def unpack(filename, destination):
>     dirname = ''
>     print('Extracting {0}'.format(filename))
>     if filename.endswith('tar.gz'):
>         tfile = tarfile.open(filename, 'r:gz')
>         tfile.extractall(destination)
>         dirname= tfile.getnames()[0]
>     elif filename.endswith('zip'):
>         zfile = zipfile.ZipFile(filename)
>         zfile.extractall(destination)
>         dirname = zfile.namelist()[0]
>     else:
>         raise NotImplementedError('Unsupported archive type')
> 
>     # a little trick to rename tool directories so they don't contain version number
>     rename_to = re.match(r'^([a-zA-Z_][^\-]*\-*)+', dirname).group(0).strip('-')
>     if rename_to != dirname:
>         sourceDirName = os.path.join(destination, dirname)
>         targetDirName = os.path.join(destination, rename_to)
>         print('Renaming {0} to {1}'.format(sourceDirName, targetDirName))
>         if os.path.isdir(targetDirName):
>             shutil.rmtree(targetDirName)
>         shutil.move(sourceDirName, targetDirName)
> 
> def get_tool(tool, unpackPath):
>     archive_name = tool['archiveFileName']
>     local_path = dist_dir + archive_name
>     url = tool['url']
>     real_hash = tool['checksum'].split(':')[1]
>     if not os.path.isfile(local_path):
>         print('Downloading ' + archive_name);
>         urlretrieve(url, local_path, report_progress)
>         sys.stdout.write("\rDone\n")
>         sys.stdout.flush()
>     else:
>         print('Tool {0} already downloaded'.format(archive_name))
>     local_hash = sha256sum(local_path)
>     if local_hash != real_hash:
>         print('Hash mismatch for {0}, delete the file and try again'.format(local_path))
>         raise RuntimeError()
>     if unpackPath:
>         unpack(local_path, unpackPath)
>     else:
>         unpack(local_path, '.')
> 
> def load_tools_list(filename, platform):
>     tools_info = json.load(open(filename))['packages'][0]['tools']
>     tools_to_download = []
>     for t in tools_info:
>         tool_platform = [p for p in t['systems'] if p['host'] == platform]
>         if len(tool_platform) == 0:
>             continue
>         tools_to_download.append(tool_platform[0])
>     return tools_to_download
> 
> def identify_platform():
>     arduino_platform_names = {'Darwin'  : {32 : 'i386-apple-darwin',   64 : 'x86_64-apple-darwin'},
>                               'Linux'   : {32 : 'i686-pc-linux-gnu',   64 : 'x86_64-pc-linux-gnu'},
>                               'LinuxARM': {32 : 'arm-linux-gnueabihf', 64 : 'aarch64-linux-gnu'},
>                               'Windows' : {32 : 'i686-mingw32',        64 : 'x86_64-mingw32'}}
>     bits = 32
>     if sys.maxsize > 2**32:
>         bits = 64
>     sys_name = platform.system()
>     if 'Linux' in sys_name and (platform.platform().find('arm') > 0 or platform.platform().find('aarch64') > 0):
>         sys_name = 'LinuxARM'
>     if 'CYGWIN_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MSYS_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MINGW' in sys_name:
>         sys_name = 'Windows'
>     return arduino_platform_names[sys_name][bits]
> 
> def main(fileJSON, name):
>     global verbose
>     # Support optional "-q" quiet mode simply
>     if len(sys.argv) == 2:
>         if sys.argv[1] == "-q":
>             verbose = False
>     # Remove a symlink generated in 2.6.3 which causes later issues since the tarball can't properly overwrite it
>     if (os.path.exists('python3/python3')):
>         os.unlink('python3/python3')
>     print('Platform: {0}'.format(identify_platform()))
>     tools_to_download = load_tools_list(fileJSON, identify_platform())
>     mkdir_p(dist_dir)
>     mkdir_p(name)
>     for tool in tools_to_download:
>         get_tool(tool, name)
> 
> if __name__ == '__main__':
>     main('package_pico_index.template.json', "rp2040")
> ~~~

### Python

[Python Release Python 3.8.5 | Python.org](https://www.python.org/downloads/release/python-385/)

>[!done] 步骤①: 下载源代码


## 嵌入式: 编译 SDK

>[!info] MAC 中真正会出现问题的主板
>1. `pico`
>2. `fireBeetleEsp32E`
>3. `esp8266`
>其余主板只需要重新编译即可


### fireBeetleEsp32E

```shell
\===error ||| Error resolving FQBN: {0} ||| [getting build properties for board dfrobot:mpython:fireBeetleEsp32E: invalid option 'FlashMode']
```

>[!tip] 删除与 FlashMode 相关的配置选项
>~~~diff
> - -fqbn=dfrobot:mpython:fireBeetleEsp32E:FlashMode=qio, FlashFreq=80, UploadSpeed=921600, DebugLevel=none
> + -fqbn=dfrobot:mpython:fireBeetleEsp32E:UploadSpeed=921600, DebugLevel=none
>~~~


> [!done] 测试: Mac, Windows, Linux (Ubuntu) 可以编译成功


### esp8266

>[!tip] 报错

>[!info] 🔎寻找出镜率高的 `.h` 文件进行单独编译
>~~~shell
>python ofile. py --build --includes -b esp8266 -l DFRobot_PS2X. h
>~~~
>如果编译失败，那就尝试其他方法
>如果编译成功, 就修改 `mindPlus/Arduino/libraries/DFRobot_PS2X/config.json` 文件, 屏蔽这个库，后面单独编译

>[!example] 找到如下几个库
>1. `DFRobot_PS2X.h`


### pico

>[!tip] 报错

>[!info] 🔎寻找出镜率高的 `.h` 文件进行单独编译
>~~~shell
>Python ofile. Py --build --includes -b esp 8266 -l DFRobot_PS 2 X. H
>~~~
>如果编译失败，那就尝试其他方法
>如果编译成功, 就修改 `mindPlus/Arduino/libraries/DFRobot_PS2X/config.json` 文件, 屏蔽这个库，后面单独编译

